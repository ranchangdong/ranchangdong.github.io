<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot之Zuul网关]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BZuul%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[使用Spring Cloud实现微服务的架构基本成型，大致是这样的: 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 编写启动类通过@EnableZuulProxy注解开启Zuul的功能：12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 映射规则：12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8081 启动测试：访问的路径中需要加上配置规则的映射路径 面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 路由前缀配置示例：123456zuul: prefix: /api # 添加路由前缀 routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 ZuulFilterZuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 过滤器执行生命周期 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行 定义过滤器类1234567891011121314151617181920212223242526272829303132@Componentpublic class LoginFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER -1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; //获取请求的参数 RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); //判断是否存在 String parameter = request.getParameter(&quot;access-token&quot;); if(StringUtils.isBlank(parameter))&#123; //不存在，未登录，则拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); &#125; return null; &#125;&#125; 测试 没有token参数时，访问失败： 添加token参数后：访问成功 负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 123456789101112131415zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms ribbon的超时时长，真实值是（read+connect）*2,必须小于hystrix熔断超时时长]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Feign远程调用]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BFeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们使用过Ribbon的负载均衡功能，大大简化了远程调用时的代码：12String baseUrl = &quot;http://user-service/user/&quot;;User user = this.restTemplate.getForObject(baseUrl + id, User.class) Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 快速入门 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Feign的客户端123456@FeignClient(&quot;user-service&quot;)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125; 开启Feign功能我们在启动类上，添加注解，开启Feign功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 启动测试, 访问接口： 负载均衡Feign中本身已经集成了Ribbon依赖和自动配置：因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置：1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 Hystix支持 Feign默认也有对Hystix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为 fallback的处理类12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName(&quot;用户查询出现异常！&quot;); return user; &#125;&#125; 然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = &quot;user-service&quot;, fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 重启测试： 我们关闭user-service服务，然后在页面访问：]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Hystix熔断]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BHystix%E7%86%94%E6%96%AD%2F</url>
    <content type="text"><![CDATA[Hystix，即熔断器。主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败 熔断器的工作机制：正常工作的情况下，客户端请求调用服务API接口：当有服务出现异常时，直接进行失败回滚，服务降级处理：当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 引入依赖首先入Hystix依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断在启动类上添加@EnableCircuitBreaker 或者只添加@SpringCloudApplication改造消费者 我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：1234567891011121314151617181920212223242526@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = &quot;queryUserByIdFallback&quot;) public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = &quot;http://user-service/user/&quot; + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info(&quot;访问用时：&#123;&#125;&quot;, end - begin); return user; &#125; public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName(&quot;用户信息查询出现异常！&quot;); return user; &#125;&#125; @HystrixCommand(fallbackMethod=”queryUserByIdFallback”)`：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 为了方便查看熔断的触发时机，我们记录请求访问时间。 也可以将@DefaultProperties(defaultFallback = “queryByIdFallback”) 配置在类上声明该类方法的默认就会执行fallback函数，返回错误提示 在原来的业务逻辑中调用这个DAO： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125; 改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 启动测试 然后运行并查看日志： 根据id进行访问 优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms 123456789默认的熔断出发要求比较高，休眠时间窗比较短 为了方便测试可以通过配置修改熔断策略circuitBreaker.requestVolumeThreshold=10circuitBreaker.sleepWindowInMilliseconds=10000circuitBreaker.errorThresholdPercentage=50解读：requestVolumeThreshold：出发熔断的最小请求次数 默认为20sleepWindowInMilliseconds：休眠时长 默认是5000毫秒errorThresholdPercentage：触发熔断的失败请求最小占比 默认是50%]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之负载均衡Robbin]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Robbin%2F</url>
    <content type="text"><![CDATA[在Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 接下来，我们就来使用Ribbon实现负载均衡。 启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。 开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：在RestTemplate的配置方法上添加@LoadBalanced注解：12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = &quot;http://user-service/user/&quot;; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果：完美 负载均衡策略默认是使用轮询 SpringBoot也帮我们提供了修改负载均衡规则的配置入口：在配置文件中添加123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 再次测试，发现结果变成了随机 重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 关闭一个user-service实例:因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。只需要简单配置即可实现Ribbon的重试：12345678910111213spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Eureka注册中心]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[原理图Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址提供者：启动后向Eureka注册自己信息（地址，提供什么服务）消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 pom.xml文件12345678910111213141516171819202122&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 根据需要导入依赖即可 编写启动类：123456789@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置：以yml文件的方式配置1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:10086/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 将user-service注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。先添加SpringCloud依赖：然后是Eureka客户端：12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意：这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看，看见有 user-service 大写的名称就说明服务注册成功了消费者从Eureka获取服务 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！、先添加SpringCloud依赖：然后是Eureka客户端：和之前的依赖是一样的在启动类开启Eureka客户端修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：123456789101112131415161718192021222324@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = &quot;http://localhost:8081/user/&quot;; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;user-service&quot;); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = &quot;http://&quot;+instance.getHost() + &quot;:&quot; + instance.getPort()+&quot;/user/&quot;; users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); return users; &#125;&#125; 最后根据你的路径访问，查看数据 Eureka详解基础架构Eureka架构中的三个核心角色： 服务注册中心Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087我们修改原来的EurekaServer配置：123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 另外一台配置恰好相反：123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：1234eureka: client: service-url: # EurekaServer地址,多个地址以&apos;,&apos;隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。服务续约在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 服务消费者 获取服务列表当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 失效剔除和自我保护失效剔除有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告：这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的RestTemplate]]></title>
    <url>%2F2019%2F03%2F07%2FSpring%E7%9A%84RestTemplate%2F</url>
    <content type="text"><![CDATA[Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：1.HttpClient2.OkHttp3.JDK原生的URLConnection（默认的）首先在项目中注册一个RestTemplate对象，可以在启动类位置注册：1234567891011121314@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject(&quot;http://localhost/hello&quot;, User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程调用方式RPC与http]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8FRPC%E4%B8%8Ehttp%2F</url>
    <content type="text"><![CDATA[远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。现在热门的Rest风格，就可以通过http协议来实现。 RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现. 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。]]></content>
      <categories>
        <category>http&amp;RPC</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统架构演变]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键存在的问题 1.代码耦合，开发维护困难 2.无法针对不同模块进行针对性优化 3.无法水平扩展 4.单点容错率低，并发能力差 垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：优点： 1.系统拆分实现了流量分担，解决了并发问题 2.可以针对不同模块进行优化 3.方便水平扩展，负载均衡，容错率提高缺点： 1.系统间相互独立，会有很多重复开发工作，影响开发效率 分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别：微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 - - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件application.properties]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6application-properties%2F</url>
    <content type="text"><![CDATA[下面列出其所有的配置 application.properties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# SPRING 相关配置 (ConfigFileApplicationListener)spring.config.name= # config file name (default to &apos;application&apos;)spring.config.location= # location of config file# profile相关配置spring.profiles= # comma list of active profiles# 系统配置相关参数 (SpringApplication)spring.main.sources=spring.main.web-environment= # detect by defaultspring.main.show-banner=truespring.main....= # see class for all properties# 日志配置相关参数logging.path=/var/logslogging.file=myapp.loglogging.config=# IDENTITY (ContextIdApplicationContextInitializer)spring.application.name=spring.application.index=# tomcat相关配置参数 (ServerProperties)server.port=8080server.address= # bind to a specific NICserver.session-timeout= # session timeout in secondsserver.context-path= # the context path, defaults to &apos;/&apos;server.servlet-path= # the servlet path, defaults to &apos;/&apos;server.tomcat.access-log-pattern= # log pattern of the access logserver.tomcat.access-log-enabled=false # is access logging enabledserver.tomcat.protocol-header=x-forwarded-proto # ssl forward headersserver.tomcat.remote-ip-header=x-forwarded-forserver.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)server.tomcat.background-processor-delay=30; # in secondsserver.tomcat.max-threads = 0 # number of threads in protocol handlerserver.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding# springmvc相关配置参数 (HttpMapperProperties)http.mappers.json-pretty-print=false # pretty print JSONhttp.mappers.json-sort-keys=false # sort keysspring.mvc.locale= # set fixed locale, e.g. en_UKspring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyyspring.mvc.message-codes-resolver-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODEspring.view.prefix= # MVC view prefixspring.view.suffix= # ... and suffixspring.resources.cache-period= # cache timeouts in headers sent to browserspring.resources.add-mappings=true # if default mappings should be added# thymeleaf相关配置参数 (ThymeleafAutoConfiguration)spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html # ;charset=&lt;encoding&gt; is addedspring.thymeleaf.cache=true # set to false for hot refresh# freemark相关配置参数 (FreeMarkerAutoConfiguration)spring.freemarker.allowRequestOverride=falsespring.freemarker.allowSessionOverride=falsespring.freemarker.cache=truespring.freemarker.checkTemplateLocation=truespring.freemarker.contentType=text/htmlspring.freemarker.exposeRequestAttributes=falsespring.freemarker.exposeSessionAttributes=falsespring.freemarker.exposeSpringMacroHelpers=falsespring.freemarker.prefix=spring.freemarker.requestContextAttribute=spring.freemarker.settings.*=spring.freemarker.suffix=.ftlspring.freemarker.templateEncoding=UTF-8spring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.viewNames= # whitelist of view names that can be resolved# groovy模板相关配置参数 (GroovyTemplateAutoConfiguration)spring.groovy.template.allowRequestOverride=falsespring.groovy.template.allowSessionOverride=falsespring.groovy.template.cache=truespring.groovy.template.configuration.*= # See Groovy&apos;s TemplateConfigurationspring.groovy.template.contentType=text/htmlspring.groovy.template.prefix=classpath:/templates/spring.groovy.template.suffix=.tplspring.groovy.template.templateEncoding=UTF-8spring.groovy.template.viewNames= # whitelist of view names that can be resolved# velocity模板相关配置参数 (VelocityAutoConfiguration)spring.velocity.allowRequestOverride=falsespring.velocity.allowSessionOverride=falsespring.velocity.cache=truespring.velocity.checkTemplateLocation=truespring.velocity.contentType=text/htmlspring.velocity.dateToolAttribute=spring.velocity.exposeRequestAttributes=falsespring.velocity.exposeSessionAttributes=falsespring.velocity.exposeSpringMacroHelpers=falsespring.velocity.numberToolAttribute=spring.velocity.prefix=spring.velocity.properties.*=spring.velocity.requestContextAttribute=spring.velocity.resourceLoaderPath=classpath:/templates/spring.velocity.suffix=.vmspring.velocity.templateEncoding=UTF-8spring.velocity.viewNames= # whitelist of view names that can be resolved# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.basename=messagesspring.messages.cacheSeconds=-1spring.messages.encoding=UTF-8# 安全相关配置参数 (SecurityProperties)security.user.name=user # login usernamesecurity.user.password= # login passwordsecurity.user.role=USER # role assigned to the usersecurity.require-ssl=false # advanced settings ...security.enable-csrf=falsesecurity.basic.enabled=truesecurity.basic.realm=Springsecurity.basic.path= # /**security.headers.xss=falsesecurity.headers.cache=falsesecurity.headers.frame=falsesecurity.headers.contentType=falsesecurity.headers.hsts=all # none / domain / allsecurity.sessions=stateless # always / never / if_required / statelesssecurity.ignored=false# 数据源相关配置参数(DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.name= # name of the data sourcespring.datasource.initialize=true # populate using data.sqlspring.datasource.schema= # a schema (DDL) script resource referencespring.datasource.data= # a data (DML) script resource referencespring.datasource.platform= # the platform to use in the schema resource (schema-$&#123;platform&#125;.sql)spring.datasource.continueOnError=false # continue even if can&apos;t be initializedspring.datasource.separator=; # statement separator in SQL initialization scriptsspring.datasource.driverClassName= # JDBC Settings...spring.datasource.url=spring.datasource.username=spring.datasource.password=spring.datasource.max-active=100 # Advanced configuration...spring.datasource.max-idle=8spring.datasource.min-idle=8spring.datasource.initial-size=10spring.datasource.validation-query=spring.datasource.test-on-borrow=falsespring.datasource.test-on-return=falsespring.datasource.test-while-idle=spring.datasource.time-between-eviction-runs-millis=spring.datasource.min-evictable-idle-time-millis=spring.datasource.max-wait-millis=# mongdb相关配置参数 (MongoProperties)spring.data.mongodb.host= # the db hostspring.data.mongodb.port=27017 # the connection port (defaults to 27107)spring.data.mongodb.uri=mongodb://localhost/test # connection URLspring.data.mongo.repositories.enabled=true # if spring data repository support is enabled# springDataJPA相关配置参数(JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.jpa.properties.*= # properties to set on the JPA connectionspring.jpa.openInView=truespring.jpa.show-sql=truespring.jpa.database-platform=spring.jpa.database=spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendorsspring.jpa.hibernate.naming-strategy= # naming classnamespring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbsspring.data.jpa.repositories.enabled=true # if spring data repository support is enabled# solr相关配置参数(SolrProperties&#125;)spring.data.solr.host=http://127.0.0.1:8983/solrspring.data.solr.zkHost=spring.data.solr.repositories.enabled=true # if spring data repository support is enabled# elasticsearch相关配置参数(ElasticsearchProperties&#125;)spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch)spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node)spring.data.elasticsearch.local=true # if local mode should be used with client nodesspring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled# flyway相关配置参数(FlywayProperties)flyway.locations=classpath:db/migrations # locations of migrations scriptsflyway.schemas= # schemas to updateflyway.initVersion= 1 # version to start migrationflyway.prefix=Vflyway.suffix=.sqlflyway.enabled=trueflyway.url= # JDBC url if you want Flyway to create its own DataSourceflyway.user= # JDBC username if you want Flyway to create its own DataSourceflyway.password= # JDBC password if you want Flyway to create its own DataSource# liquibase相关配置参数(LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yamlliquibase.contexts= # runtime contexts to useliquibase.default-schema= # default database schema to useliquibase.drop-first=falseliquibase.enabled=true# JMXspring.jmx.enabled=true # Expose MBeans from Spring# rabbitmq相关配置参数(RabbitProperties)spring.rabbitmq.host= # connection hostspring.rabbitmq.port= # connection portspring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111)spring.rabbitmq.username= # login userspring.rabbitmq.password= # login passwordspring.rabbitmq.virtualhost=spring.rabbitmq.dynamic=# redis相关配置参数(RedisProperties)spring.redis.host=localhost # server hostspring.redis.password= # server passwordspring.redis.port=6379 # connection portspring.redis.pool.max-idle=8 # pool settings ...spring.redis.pool.min-idle=0spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1# activemq相关配置参数(ActiveMQProperties)spring.activemq.broker-url=tcp://localhost:61616 # connection URLspring.activemq.user=spring.activemq.password=spring.activemq.in-memory=true # broker kind to create if no broker-url is specifiedspring.activemq.pooled=false# hornetq相关配置参数(HornetQProperties)spring.hornetq.mode= # connection mode (native, embedded)spring.hornetq.host=localhost # hornetQ host (native mode)spring.hornetq.port=5445 # hornetQ port (native mode)spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar)spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer)spring.hornetq.embedded.persistent=false # message persistencespring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled)spring.hornetq.embedded.queues= # comma separate queues to create on startupspring.hornetq.embedded.topics= # comma separate topics to create on startupspring.hornetq.embedded.cluster-password= # customer password (randomly generated by default)# JMS (JmsProperties)spring.jms.pub-sub-domain= # false for queue (default), true for topic# springbatch相关配置参数(BatchDatabaseInitializer)spring.batch.job.names=job1,job2spring.batch.job.enabled=truespring.batch.initializer.enabled=truespring.batch.schema= # batch schema to load# aop相关配置参数spring.aop.auto=spring.aop.proxy-target-class=# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding=false# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # enabled by default# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by defaultspring.mobile.devicedelegatingviewresolver.normalPrefix=spring.mobile.devicedelegatingviewresolver.normalSuffix=spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/spring.mobile.devicedelegatingviewresolver.mobileSuffix=spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/spring.mobile.devicedelegatingviewresolver.tabletSuffix=# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.port= # defaults to &apos;server.port&apos;management.address= # bind to a specific NICmanagement.contextPath= # default to &apos;/&apos;# ENDPOINTS (AbstractEndpoint subclasses)endpoints.autoconfig.id=autoconfigendpoints.autoconfig.sensitive=trueendpoints.autoconfig.enabled=trueendpoints.beans.id=beansendpoints.beans.sensitive=trueendpoints.beans.enabled=trueendpoints.configprops.id=configpropsendpoints.configprops.sensitive=trueendpoints.configprops.enabled=trueendpoints.configprops.keys-to-sanitize=password,secretendpoints.dump.id=dumpendpoints.dump.sensitive=trueendpoints.dump.enabled=trueendpoints.env.id=envendpoints.env.sensitive=trueendpoints.env.enabled=trueendpoints.health.id=healthendpoints.health.sensitive=falseendpoints.health.enabled=trueendpoints.info.id=infoendpoints.info.sensitive=falseendpoints.info.enabled=trueendpoints.metrics.id=metricsendpoints.metrics.sensitive=trueendpoints.metrics.enabled=trueendpoints.shutdown.id=shutdownendpoints.shutdown.sensitive=trueendpoints.shutdown.enabled=falseendpoints.trace.id=traceendpoints.trace.sensitive=trueendpoints.trace.enabled=true# MVC ONLY ENDPOINTSendpoints.jolokia.path=jolokiaendpoints.jolokia.sensitive=trueendpoints.jolokia.enabled=true # when using Jolokiaendpoints.error.path=/error# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.enabled=trueendpoints.jmx.domain= # the JMX domain, defaults to &apos;org.springboot&apos;endpoints.jmx.unique-names=falseendpoints.jmx.enabled=trueendpoints.jmx.staticNames=# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# REMOTE SHELLshell.auth=simple # jaas, key, simple, springshell.command-refresh-interval=-1shell.command-path-pattern= # classpath*:/commands/**, classpath*:/crash/commands/**shell.config-path-patterns= # classpath*:/crash/*shell.disabled-plugins=false # don&apos;t expose pluginsshell.ssh.enabled= # ssh settings ...shell.ssh.keyPath=shell.ssh.port=shell.telnet.enabled= # telnet settings ...shell.telnet.port=shell.auth.jaas.domain= # authentication settings ...shell.auth.key.path=shell.auth.simple.user.name=shell.auth.simple.user.password=shell.auth.spring.roles=# GIT INFOspring.git.properties= # resource ref to generated git info properties file]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot应用启动器]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[spring Boot应用启动器基本的一共有44种，具体如下:1.spring-boot-starter这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。 2.spring-boot-starter-actuator帮助监控和管理应用。 3.spring-boot-starter-amqp通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol）。 4.spring-boot-starter-aop支持面向方面的编程即AOP，包括spring-aop和AspectJ。 5.spring-boot-starter-artemis通过Apache Artemis支持JMS的API（Java Message Service API）。 6.spring-boot-starter-batch支持Spring Batch，包括HSQLDB数据库。 7.spring-boot-starter-cache支持Spring的Cache抽象。 8.spring-boot-starter-cloud-connectors支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。 9.spring-boot-starter-data-elasticsearch支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。 10.spring-boot-starter-data-gemfire支持GemFire分布式数据存储，包括spring-data-gemfire。 11.spring-boot-starter-data-jpa支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、hibernate。 12.spring-boot-starter-data-MongoDB支持MongoDB数据，包括spring-data-mongodb。 13.spring-boot-starter-data-rest通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。 14.spring-boot-starter-data-solr支持Apache Solr搜索平台，包括spring-data-solr。 15.spring-boot-starter-freemarker支持FreeMarker模板引擎。 16.spring-boot-starter-groovy-templates支持Groovy模板引擎。 17.spring-boot-starter-hateoas通过spring-hateoas支持基于HATEOAS的RESTful Web服务。 18.spring-boot-starter-hornetq通过HornetQ支持JMS。 19.spring-boot-starter-integration支持通用的spring-integration模块。 20.spring-boot-starter-jdbc支持JDBC数据库。 21.spring-boot-starter-jersey支持Jersey RESTful Web服务框架。 22.spring-boot-starter-jta-atomikos通过Atomikos支持JTA分布式事务处理。 23.spring-boot-starter-jta-bitronix通过Bitronix支持JTA分布式事务处理。 24.spring-boot-starter-mail支持javax.mail模块。 25.spring-boot-starter-mobile支持spring-mobile。 26.spring-boot-starter-mustache支持Mustache模板引擎。 27.spring-boot-starter-Redis支持Redis键值存储数据库，包括spring-redis。 28.spring-boot-starter-security支持spring-security。 29.spring-boot-starter-social-facebook支持spring-social-facebook 30.spring-boot-starter-social-linkedin支持pring-social-linkedin 31.spring-boot-starter-social-twitter支持pring-social-twitter 32.spring-boot-starter-test支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。 33.spring-boot-starter-thymeleaf支持Thymeleaf模板引擎，包括与Spring的集成。 34.spring-boot-starter-velocity支持Velocity模板引擎。 35.spring-boot-starter-webS支持全栈式Web开发，包括Tomcat和spring-webmvc。 36.spring-boot-starter-websocket支持WebSocket开发。 37.spring-boot-starter-ws支持Spring Web Services。Spring Boot应用启动器面向生产环境的还有2种，具体如下： 1.spring-boot-starter-actuator增加了面向产品上线相关的功能，比如测量和监控。 2.spring-boot-starter-remote-shell增加了远程ssh shell的支持。最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下： 1.spring-boot-starter-jetty引入了Jetty HTTP引擎（用于替换Tomcat）。 2.spring-boot-starter-log4j支持Log4J日志框架。 3.spring-boot-starter-logging引入了Spring Boot默认的日志框架Logback。 4.spring-boot-starter-tomcat引入了Spring Boot默认的HTTP引擎Tomcat。 5.spring-boot-starter-undertow引入了Undertow HTTP引擎（用于替换Tomcat）。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用AOP统一处理Web请求日志]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E4%BD%BF%E7%94%A8AOP%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[首先添加aop依赖123456&lt;!-- AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 写一个切面类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.gyf.aop;import java.util.Enumeration;import javax.servlet.http.HttpServletRequest;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@Aspect@Componentpublic class WebLogAspect &#123; private Logger logger = Logger.getLogger(getClass()); @Pointcut(&quot;execution(public * com.gyf.controller..*.*(..))&quot;) public void webLog() &#123; &#125; @Before(&quot;webLog()&quot;) public void doBefore(JoinPoint joinPoint) throws Throwable &#123; // 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 记录下请求内容 logger.info(&quot;---------------request----------------&quot;); logger.info(&quot;URL : &quot; + request.getRequestURL().toString()); logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod()); logger.info(&quot;IP : &quot; + request.getRemoteAddr()); Enumeration&lt;String&gt; enu = request.getParameterNames(); while (enu.hasMoreElements()) &#123; String name = (String) enu.nextElement(); logger.info(&quot;name:&quot; + name + &quot;value&quot; + request.getParameter(name)); &#125; &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;) public void doAfterReturning(Object ret) throws Throwable &#123; logger.info(&quot;---------------response----------------&quot;); // 处理完请求，返回内容 logger.info(&quot;RESPONSE : &quot; + ret); &#125;&#125; @Aspect:作用是把当前类标识为一个切面供容器读取Aspect的意思是面向切面编程，一个类前面加上@Aspect说明这个类使用了这个技术，很有可能是在进行声明式事务处理 1.这里的可以把这里public void webLog() {}方法理解成具体pointcut（切入点）的声明，实际对应的切入点是“execution(public * com.cc.springboot.controller…(..))”； 2.@AfterReturning，是在具体业务方法返回后的操作（比如下面IndexController类中的getUserName()方法），所以returning=”ret”对应的是业务方法 的返回值，不是切入点声明的返回值，也就是returning=”ret”的“ret”就是具体的方法(public * com.cc.springboot.controller…(..))的返回值，对应public void afterReturning(ret returnValue) 的方法参数，名称一定要对应，在方法返回后，可以进行一些操作，比如输出返回值或者根据返回值进行一些操作。 然后开启Spring 随便使用一个业务方法 就可以看到控制台打印的日志了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Log4j]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88Log4j%2F</url>
    <content type="text"><![CDATA[Spring Boot 配合log4j实现日志输出 导入Log4j属性文件log4j.properties注意，复制时要把每一行后面的空格去除 这里配置的 日志文件地址为 C:/Users/10301/Desktop/test/logs/info/info.log1234567891011121314log4j.rootLogger=INFO,Console,File log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.outlog4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c - %L]%m%n log4j.appender.File = org.apache.log4j.RollingFileAppender log4j.appender.File.File = C:/Users/10301/Desktop/test/logs/info/info.log log4j.appender.File.MaxFileSize = 10MB log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c - %L]%m%n 配置pom.xml 去除springboot的logging，添加log4j，因为自带的logging不启效果springboot下的Log4j的版本最新1.3.8，如果你的springboot的parent版本过高，那在在添加log4j自己版本 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.micai&lt;/groupId&gt; &lt;artifactId&gt;micai-springboot-log4j-8&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;micai-springboot-log4j-8&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Spring Boot log4j依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ##具体打印日志的java类，如下： 123456789101112131415161718192021package com.micai.springboot.web; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestController //提供实现了REST API，可以服务JSON,XML或者其他。这里是以String的形式渲染出结果。public class HelloWorldController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(&quot;/&quot;) //提供路由信息，”/“路径的HTTP Request都会被映射到sayHello方法进行处理。 public String sayHello()&#123; logger.info(&quot;hello world&quot;); return &quot;Hello,World!&quot;; &#125; &#125; 启动Spring 就可以在上面的路径的日志文件中看到运行日志]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MyBatis配置多个数据源]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88MyBatis%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[配置文件中新增两个数据源12345678910spring.datasource.test1.driverClassName=com.mysql.jdbc.Driverspring.datasource.test1.url=jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.test1.username=rootspring.datasource.test1.password=123456spring.datasource.test2.driverClassName=com.mysql.jdbc.Driverspring.datasource.test2.url=jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.test2.username=rootspring.datasource.test2.password=123456 在数据库中创建两个数据库12345678910111213141516use test1;CREATE table user( id int PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50), password VARCHAR(50), email VARCHAR(50), birthday TIMESTAMP);use test2;CREATE table customer( id int PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), tel VARCHAR(50)); 再src下先创建两个包 com.gyf.test1.mapper ， com.gyf.test2.mapper 编写两个数据源配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//----------text1package com.gyf.datasource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test1.mapper&quot;,sqlSessionFactoryRef=&quot;test1SqlSessionFactory&quot;)public class DataSource01 &#123; /** * @return 返回test1数据库的数据源 */ @Bean(name=&quot;test1DataSource&quot;) @Primary//主数据源 @ConfigurationProperties(prefix=&quot;spring.datasource.test1&quot;) public DataSource dateSource()&#123; return DataSourceBuilder.create().build(); &#125; /** * @return 返回test1数据库的会话工厂 */ @Bean(name = &quot;test1SqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource ds) throws Exception&#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); return bean.getObject(); &#125; /** * @return 返回test1数据库的事务 */ @Bean(name = &quot;test1TransactionManager&quot;) @Primary public DataSourceTransactionManager transactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; /** * @return 返回test1数据库的会话模版 */ @Bean(name = &quot;test1SqlSessionTemplate&quot;) public SqlSessionTemplate sqlSessionTemplate( @Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125;//------------text2package com.gyf.datasource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test2.mapper&quot;,sqlSessionFactoryRef=&quot;test2SqlSessionFactory&quot;)public class DataSource02 &#123; /** * @return 返回test2数据库的数据源 */ @Bean(name=&quot;test2DataSource&quot;) @ConfigurationProperties(prefix=&quot;spring.datasource.test2&quot;) public DataSource dateSource()&#123; return DataSourceBuilder.create().build(); &#125; /** * @return 返回test2数据库的会话工厂 */ @Bean(name = &quot;test2SqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;test2DataSource&quot;) DataSource ds) throws Exception&#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); return bean.getObject(); &#125; /** * @return 返回test2数据库的事务 */ @Bean(name = &quot;test2TransactionManager&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;test2DataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; /** * @return 返回test2数据库的会话模版 */ @Bean(name = &quot;test2SqlSessionTemplate&quot;) public SqlSessionTemplate sqlSessionTemplate( @Qualifier(&quot;test2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 然后编写Mapper里的类和映射SQL的xml文件如果使用的是com.gyf.test1.mapper下的类就是使用的第一个数据源的数据如果使用的是com.gyf.test2.mapper下的类就是使用的第二个数据源的数据 如果你在一个service的方法里同时使用了两个数据源 开启了事务注解 @Transactoinal 并出现了的异常很显然，有多个事务，容器不知道我们要的是哪个事务、如何解决这个错误 下面会给大家讲解 springboot中的多事务管理使用springboot+jta+atomikos 分布式事物管理解决方案 添加jta事务依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt;&lt;/dependency&gt; 修改数据库连接配置数据 123456789101112131415161718192021222324252627# Mysql 1mysql.datasource.test1.url = jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8mysql.datasource.test1.username = rootmysql.datasource.test1.password = 123456mysql.datasource.test1.minPoolSize = 3mysql.datasource.test1.maxPoolSize = 25mysql.datasource.test1.maxLifetime = 20000mysql.datasource.test1.borrowConnectionTimeout = 30mysql.datasource.test1.loginTimeout = 30mysql.datasource.test1.maintenanceInterval = 60mysql.datasource.test1.maxIdleTime = 60mysql.datasource.test1.testQuery = select 1# Mysql 2mysql.datasource.test2.url =jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8mysql.datasource.test2.username =rootmysql.datasource.test2.password =123456mysql.datasource.test2.minPoolSize = 3mysql.datasource.test2.maxPoolSize = 25mysql.datasource.test2.maxLifetime = 20000mysql.datasource.test2.borrowConnectionTimeout = 30mysql.datasource.test2.loginTimeout = 30mysql.datasource.test2.maintenanceInterval = 60mysql.datasource.test2.maxIdleTime = 60mysql.datasource.test2.testQuery = select 1 添加2个配置模型 模型放在com.gyf.dbconfig包 12345678910111213141516171819202122232425262728293031323334353637@ConfigurationProperties(&quot;mysql.datasource.test1&quot;)public class DBConfig1 &#123; private String url; private String username; private String password; private int minPoolSize; private int maxPoolSize; private int maxLifetime; private int borrowConnectionTimeout; private int loginTimeout; private int maintenanceInterval; private int maxIdleTime; private String testQuery; ...... &#125; @ConfigurationProperties(&quot;mysql.datasource.test2&quot;)public class DBConfig2 &#123; private String url; private String username; private String password; private int minPoolSize; private int maxPoolSize; private int maxLifetime; private int borrowConnectionTimeout; private int loginTimeout; private int maintenanceInterval; private int maxIdleTime; private String testQuery; ...... &#125; 重定两个数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.gyf.datasource;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.gyf.dbconfig.DBConfig1;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test1.mapper&quot;,sqlSessionFactoryRef=&quot;test1SqlSessionFactory&quot;)public class DataSource01 &#123; // 配置数据源 @Primary @Bean(name = &quot;test1DataSource&quot;) public DataSource testDataSource(DBConfig1 testConfig) throws SQLException &#123; MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(testConfig.getUrl()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); mysqlXaDataSource.setPassword(testConfig.getPassword()); mysqlXaDataSource.setUser(testConfig.getUsername()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName(&quot;test1DataSource&quot;); xaDataSource.setMinPoolSize(testConfig.getMinPoolSize()); xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize()); xaDataSource.setMaxLifetime(testConfig.getMaxLifetime()); xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout()); xaDataSource.setLoginTimeout(testConfig.getLoginTimeout()); xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval()); xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime()); xaDataSource.setTestQuery(testConfig.getTestQuery()); return xaDataSource; &#125; @Bean(name = &quot;test1SqlSessionFactory&quot;) public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; @Bean(name = &quot;test1SqlSessionTemplate&quot;) public SqlSessionTemplate testSqlSessionTemplate( @Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125;-------------------------------------------------------package com.gyf.datasource;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.gyf.dbconfig.DBConfig2;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test2.mapper&quot;,sqlSessionFactoryRef=&quot;test2SqlSessionFactory&quot;)public class DataSource02 &#123; // 配置数据源 @Bean(name = &quot;test2DataSource&quot;) public DataSource testDataSource(DBConfig2 testConfig) throws SQLException &#123; MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(testConfig.getUrl()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); mysqlXaDataSource.setPassword(testConfig.getPassword()); mysqlXaDataSource.setUser(testConfig.getUsername()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName(&quot;test2DataSource&quot;); xaDataSource.setMinPoolSize(testConfig.getMinPoolSize()); xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize()); xaDataSource.setMaxLifetime(testConfig.getMaxLifetime()); xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout()); xaDataSource.setLoginTimeout(testConfig.getLoginTimeout()); xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval()); xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime()); xaDataSource.setTestQuery(testConfig.getTestQuery()); return xaDataSource; &#125; @Bean(name = &quot;test2SqlSessionFactory&quot;) public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test2DataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; @Bean(name = &quot;test2SqlSessionTemplate&quot;) public SqlSessionTemplate testSqlSessionTemplate( @Qualifier(&quot;test2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 在APP类中添加注解12345678910@SpringBootApplication@EnableConfigurationProperties(value = &#123;DBConfig1.class,DBConfig2.class&#125;)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class,args); &#125;&#125; 这样就解决了多个事务管理问题]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MyBatis]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录 如何让将MyBatis与SpringBoot进行整合pom导入 1234567891011121314151617181920212223242526272829303132&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybaties --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.properties文件中属性配置 123456#数据库配置spring.datasource.url=jdbc:mysql://localhost:3306/db?characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver Mapper中以xml形式编写SQL语句 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.gyf.mapper.UserMapper&quot; &gt; &lt;insert id=&quot;save&quot;&gt; insert into t_user (username,password) VALUES(#&#123;0&#125;,#&#123;1&#125;) &lt;/insert&gt; &lt;select id=&quot;findByUsername&quot; resultType=&quot;com.gyf.model.User&quot; parameterType=&quot;string&quot;&gt; select * from t_user where username = #&#123;username,jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 注意这里需要在pom中添加下面代码 1234567891011&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Controller这里为了简写直接在Controller层中引入了Mapper在实际中Mapper是在service层中引入的 1234567891011121314151617181920212223package com.gyf.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.gyf.mapper.UserMapper;import com.gyf.model.User;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserMapper userMapper; @ResponseBody @RequestMapping(&quot;/add/&#123;name&#125;&quot;) public int add(String name)&#123; return userMapper.insert(name,&quot;e10adc3949ba59abbe56e057f20f883e&quot;); &#125;&#125; 运行App类 123456789101112131415package com.gyf.app;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 在浏览器地址栏中 输入localhost:8080/user/add/参数 然后再去数据库查看数据是否添加成功]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Freemarker的使用]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88Freemarker%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板引擎 Freemarker它是基于模板文件生成其他文本的通用工具FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。当你使用上述模板引擎中的时候，它们默认的模板配置路径为：src/main/resources/templates 特点： 轻量级模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中 能生成各种文本，如html，xml，java，等 入门简单，它是用java编写的，很多语法和java相似 二.Springboot-freemarker工程配置详解 1.pom.xml文件详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot-freemarker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-freemarker :: Spring Boot 集成 FreeMarker 案例&lt;/name&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt; &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Freemarker 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 我们在pom.xml中增加Spring Boot FreeMarker依赖 2.配置FreeMarker 在application.properties中加入FreeMarker相关配置:123456789101112## Freemarker 配置## 文件配置路径spring.freemarker.template-loader-path=classpath:/web/spring.freemarker.cache=falsespring.freemarker.charset=UTF-8spring.freemarker.check-template-location=truespring.freemarker.content-type=text/htmlspring.freemarker.expose-request-attributes=truespring.freemarker.expose-session-attributes=truespring.freemarker.request-context-attribute=requestspring.freemarker.suffix=.ftl ##3.展示层Controller详解 12345678910111213141516171819202122232425/** * @author WJ * @date 2018/04/26 */ @Controller public class CityController &#123; @Autowired private CityService cityService; @RequestMapping(value = &quot;/api/city/&#123;id&#125;&quot;, method = RequestMethod.GET) public String findOne(Model model, @PathVariable(&quot;id&quot;) Long id)&#123; model.addAttribute(&quot;city&quot; , cityService.findOne(id)); return &quot;city&quot;; &#125; @RequestMapping(value = &quot;/api/city&quot;, method = RequestMethod.GET) public String findAll(Model model)&#123; List&lt;City&gt; cityList = cityService.findAll(); model.addAttribute(&quot;cityList&quot;, cityList); return &quot;cityList&quot;; &#125; &#125; 注意 这里不是走HTTP+JSON模式,使用了@Controller而不是先前的@RestController方法返回值是String类型，和.application.properties配置的Freemarker文件配置路径下的各个*.ftl文件名一致，这样才会准确的把数据渲染到ftl文件里面进行展示用Model类，向Model加入数据，并指定在该数据在Freemarker取值指定的名称。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot全局捕获异常]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E5%85%A8%E5%B1%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[@ExceptionHeandler 表示拦截异常@ControllerAdivcecontroller 的一个辅助类，最常用的就是全局异常处理的切面类可以指定扫描范围约定了几种可行的返回值，如果是直接返回model类的话，需要使用@ResponseBody进行JSON转换 案例 在一个自己定义的包中创建一个全局异常类12345678910111213@ControllerAdvice//切面public class GlobalExceptionHandler &#123; @ExceptionHandler(RuntimeException.class)//捕获运行时异常 @ResponseBody public Map&lt;String,Object&gt; exceptionHander()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;errorCode&quot;, &quot;101&quot;); map.put(&quot;errorMsg&quot;, &quot;系統错误!&quot;); return map; &#125;&#125; 在某个的映射的方法中添加上 int i =10/0 的算术异常 然后再启动Spring 最后在浏览器地址栏中输入该方法的路径 如果页面显示 12&#123;&quot;errorCode&quot;:&quot;101&quot;,&quot;errorMsg&quot;:&quot;系統错误&quot;&#125; 那么就说明SpringBoot的全局捕获异常设置成功]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云深]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%91%E6%B7%B1%2F</url>
    <content type="text"><![CDATA[云深第一篇文章这是三级列表哦 列表1 列表2 a 字体列表哦 b 字体列表哈 列表3 云深导航 字体是斜线的字体是加粗的 &lt;html&gt;&lt;/html&gt; 这个123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 在博客中添加图片 ![云深不知处](图片路径) &lt;/body&gt;&lt;/html&gt; 这里的内容是引用的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
