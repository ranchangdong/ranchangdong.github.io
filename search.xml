<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringDataJPA]]></title>
    <url>%2F2019%2F04%2F03%2FSpringDataJPA%2F</url>
    <content type="text"><![CDATA[springDataJpa的概述Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！ Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦 SpringData Jpa 极大简化了数据库访问层代码。 如何简化的呢？ 使用了SpringDataJpa，我们的dao层中只需要写接口，就自动具有了增删改查、分页查询等方法。 Spring Data JPA的快速入门Spring Data JPA完成客户的基本CRUD操作 搭建Spring Data JPA的开发环境使用Spring Data JPA，需要整合Spring与Spring Data JPA，并且需要提供JPA的服务提供者hibernate，所以需要导入spring相关坐标，hibernate坐标，数据库驱动坐标等pom文件配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- hibernate beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate end --&gt; &lt;!-- c3p0 beg --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 end --&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el beg 使用spring data jpa 必须引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el end --&gt; &lt;/dependencies&gt; 整合Spring Data JPA与Spring文件名为 ：applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt; &lt;!--Spring和 Spring Date jpa 的配置--&gt; &lt;!--创建entityManagerFactory对象交给Spring容器管理--&gt; &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!--配置的扫描的包（实体类所在的包）--&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;com.jpa.pojo&quot;&gt;&lt;/property&gt; &lt;!--JPA的是实现厂家--&gt; &lt;property name=&quot;persistenceProvider&quot;&gt; &lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;!--JPA的供应商的适配器--&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt; &lt;!--配置是否自动创建数据库表--&gt; &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt; &lt;!--指定数据库类型--&gt; &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt; &lt;!--数据库方言--&gt; &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt; &lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--JPA的方言 ： 高级特性--&gt; &lt;property name=&quot;jpaDialect&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;rcd520.&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///jpa&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--整合SpringDataJPA--&gt; &lt;jpa:repositories base-package=&quot;com.jpa.dao&quot; transaction-manager-ref=&quot;transactionManager&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot;&gt;&lt;/jpa:repositories&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt; &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--声明式事务--&gt; &lt;!--配置包扫描--&gt; &lt;context:component-scan base-package=&quot;com.jpa&quot;/&gt;&lt;/beans&gt; 编写实体类配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import javax.persistence.*;/** * 客户实体类 * 配置映射关系 * 1.实体类和表的映射关系 * @Entity 声明这是一个实体类 * @Table 配置实体类和表的映射关系 * name: 配置数据库表的名称 * 2.实体类中属性和表中字段的映射关系 * * */@Entity@Table(name = &quot;cst_customer&quot;)public class Customer &#123; /** * @Id： 声明主键的配置 * @GeneratedValue: 配置主键生成策略 * strategy * GenerationType.IDENTITY： 自增 * * 底层数据库必须支持自动增长 * GenerationType.SEQUENCE : 序列 oracle * * 底层数据库必须支持序列 * GenerationType.TABLE : jpa提供的一种机制 通过一张数据库表的形式帮助我们完成主键自增 * GenerationType.AUTO : 有程序自动的帮助我们选择主键生成策略 * @Column:配置属性和字段的映射关系 * name: 数据库表中字段的名称 * */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;cust_id&quot;) private Long custId; //客户主键 @Column(name = &quot;cust_name&quot;) private String custName; //客户名称 @Column(name = &quot;cust_source&quot;) private String custSource; //客户来源 @Column(name = &quot;cust_industry&quot;) private String custIndustry; //客户所属行业 @Column(name = &quot;cust_level&quot;) private String custLevel; //客户级别 @Column(name = &quot;cust_address&quot;) private String custAddress; //客户地址 @Column(name = &quot;cust_phone&quot;) private String custPhone; //客户的联系方式 @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;custId=&quot; + custId + &quot;, custName=&apos;&quot; + custName + &apos;\&apos;&apos; + &quot;, custSource=&apos;&quot; + custSource + &apos;\&apos;&apos; + &quot;, custIndustry=&apos;&quot; + custIndustry + &apos;\&apos;&apos; + &quot;, custLevel=&apos;&quot; + custLevel + &apos;\&apos;&apos; + &quot;, custAddress=&apos;&quot; + custAddress + &apos;\&apos;&apos; + &quot;, custPhone=&apos;&quot; + custPhone + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125; public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125;&#125; 编写一个符合springDataJpa的dao层接口只需要编写dao层接口，不需要编写dao层接口的实现类dao层接口规范符合SpringDateJPA接口规范 JpaRepository&lt;操作的实体类类型，实体类中主键属性类型&gt;, 封装了基本的CRUD的操作 JpaSpecificationExecutor&lt;操作的实体类类型&gt; 封装了复杂查询 12public interface CustomerDao extends JpaRepository&lt;Customer,Long&gt; ,JpaSpecificationExecutor&lt;Customer&gt;&#123;&#125; 以下是简单的CRUD方法 save(customer):保存或者更新（依据：传递的实体类对象中，是否包含id属性） delete（id） ：根据id删除 findAll() : 查询全部 count(): 统计查询 exists(id): 根据ID查询是否存在 返回boolean值 findOne(id) : 立即加载 等同于 em.find()getOne(id) : 延迟加载 等同于 em.getReference()运行getOne()方法需要添加 @Transactional :保证getOne()正常运行 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 根据ID查询 */ @Test public void findOne()&#123; Customer customer = customerDao.findOne(1L); System.out.println(customer); &#125; /** * save:保存或者更新 * 根据传递的对象是否存在主键ID * 如果没有ID主键属性 ：保存 * 存在ID主键属性 ：根据ID主键查询数据， 更新数据 */ @Test public void testSave()&#123; Customer customer = new Customer(); customer.setCustName(&quot;程序员&quot;); customer.setCustLevel(&quot;VIP&quot;); customer.setCustIndustry(&quot;搬砖&quot;); customerDao.save(customer); &#125; @Test public void testUpdate()&#123; Customer customer = new Customer(); customer.setCustId(2L); customer.setCustName(&quot;程序员&quot;); customer.setCustLevel(&quot;VIP&quot;); customer.setCustIndustry(&quot;不再搬砖&quot;); customerDao.save(customer); &#125; /** * 删除 * */ @Test public void testDelete()&#123; customerDao.delete(2L); &#125; /** * 查询所有 */ @Test public void testFindAll()&#123; List&lt;Customer&gt; all = customerDao.findAll(); for (Customer customer : all) &#123; System.out.println(customer); &#125; &#125; /** * 统计查询 ：查询客户的总数量 */ @Test public void testCount()&#123; long count = customerDao.count(); //查询全部的用户数量 System.out.println(count); &#125; /** * 测试：判断ID为4的客户是否存在 * 可以查询一下id为4的客户 * 如果值为空 代表不存在 如果不为空 代表存在 * 判断数据库ID为4的客户的数量 * 如果大于0 代表存在 如果等于0 代表不存在 */ @Test public void testExie()&#123; boolean exists = customerDao.exists(2L); System.out.println(exists); &#125; /** * 根据ID从数据库查询 * @Transactional :保证getOne()正常运行 * findOne() : 立即加载 等同于 em.find() * getOne() : 延迟加载 等同于 em.getReference() */ @Test @Transactional public void testGetOne()&#123; Customer customer = customerDao.getOne(1L); System.out.println(customer); &#125; 复杂查询jpql的查询方式jpql ： jpa query language （jpq查询语言）特点：语法或关键字和sql语句类似 查询的是类和类中的属性需要将JPQL语句配置到接口方法上1.特有的查询：需要在dao接口上配置方法2.在新添加的方法上，使用注解的形式配置jpql查询语句3.注解 ： @Query1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 根据客户名称查询客户 * jpql: from Customer where custName = ? * 配置jpql语句 使用@Query注解 */ @Query(value = &quot;from Customer where custName = ?&quot;) public Customer findJpql(String custName); /** * 根据酷虎名称和客户Id查询客户 * jpql: from Customer where custName = ? and custId = ? * * 对于多个占位符 参数 * 赋值的时候默认的情况下 占位符的位置需要和方法参数中的位置保持一致 * * 可以指定占位符的位置 * ？ 索引的方式 指定次占位的取值来源 * 例如： * @Query(value = &quot;from Customer where custName = ?2 and custId = ?1 &quot;) * public Customer findCustNameAndId(Long id,String name); * */ @Query(value = &quot;from Customer where custName = ? and custId = ?&quot;) public Customer findCustNameAndId(String name,Long id); /** * 使用JPQL王城更新操作 * 根据id更新 客户的名称 * jpql: update Customer set custName = ? where custId = ? * @Query：代表的是进行查询 * 声明此方法是用来更新 需要使用 * @Modifying 注解 * 表示此方法是用来更新 */ @Query(value = &quot;update Customer set custName = ?2 where custId = ?1 &quot;) @Modifying() public void updateCustomer(long custId,String custName);``` 测试代码： @Autowired private CustomerDao customerDao; @Test public void testFindJpql()&#123; Customer jpql = customerDao.findJpql(&quot;小胖&quot;); System.out.println(jpql); &#125; @Test public void testFindCustNameAndId()&#123; Customer customer = customerDao.findCustNameAndId(&quot;小胖&quot;, 1L); System.out.println(customer); &#125; 在使用JPQL执行更新操作时 需要添加事务 @Transactional 并且 JPQL默认执行事务回滚 需要使用 @Rollback :是否开启自动回滚 (value = false) 关闭事务回滚 默认 等于 true @Test @Transactional @Rollback(value = false) public void testUpdateCustomer()&#123; customerDao.updateCustomer(2L,&quot;小胖子&quot;); &#125; sql语句的查询1.特有的查询：需要在dao接口上配置方法2.在新添加的方法上，使用注解的形式配置sql查询语句3.注解 ： @Queryvalue ：jpql语句 | sql语句nativeQuery ：false（使用jpql查询） | true（使用本地查询：sql查询）是否使用本地查询12345678910111213141516171819202122232425 /** * 使用sql的形式进行查询 * 查询全部用户 * select * from cust_customer * */// @Query(value = &quot;select * from cst_customer&quot; ,nativeQuery = true) @Query(value = &quot;select * from cst_customer where cust_name like ?1 &quot; ,nativeQuery = true) public List&lt;Customer &gt; findSql(String name);测试： //测试sql方式查询@Testpublic void testFindSql()&#123; List&lt;Customer&gt; sql = customerDao.findSql(&quot;小胖&quot;); for (Customer customer : sql) &#123; System.out.println(customer); &#125;&#125;``` 方法名称规则查询方法名的查询findBy : 查询对象中的属性名称 （首字母大写） 查询条件再springdatajpa的运行阶段会根据方法名称进行解析 findBy from xxx(实体类)属性名称 wherefindBy + 属性名称 （根据属性名称进行完成匹配的查询）findBy + 属性名称 + “查询方式（Like | isnull ）”多条件查询findBy + 属性名 + “查询方式” + 多个条件的连接符（and | or） + 属性名 + “查询方式”1234public Customer findByCustName(String name);public List&lt;Customer&gt; findByCustNameLike(String name);//使用客户名称模糊匹配和客户所属行业精准匹配的查询public Customer findByCustNameLikeAndCustIndustry(String name,String industry); 测试： //以方法名称规则查询 @Test public void testFindByCustName(){ Customer customer = customerDao.findByCustName(&quot;小胖&quot;); System.out.println(customer); } //以方法名称规则查询 @Test public void testFindByCustNameLike(){ List&lt;Customer&gt; customers = customerDao.findByCustNameLike(&quot;小胖%&quot;); for (Customer customer : customers) { System.out.println(customer); } } //以方法名称规则查询 @Test public void testFindByCustNameLikeAndCustIndustry(){ Customer customer = customerDao.findByCustNameLikeAndCustIndustry(&quot;小胖%&quot;,&quot;IT&quot;); System.out.println(customer); }]]></content>
      <categories>
        <category>SpringData</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPQL的简单使用]]></title>
    <url>%2F2019%2F04%2F02%2FJPQL%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JPA中的复杂查询 JPQL全称Java Persistence Query Language 基于首次在EJB2.0中引入的EJB查询语言(EJB QL),Java持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将SQL语法和简单查询语义绑定在一起·使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的SQL。 其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性。 sql: 查询的是表和表中的字段jpql: 查询的是实体类和类中的属性 jpql和sql语句的语法相似 查询全部12345678910111213141516171819202122@Test public void testFindAll()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); String jpql = &quot;from com.jap.pojo.Customer&quot;; Query query = em.createQuery(jpql); List resultList = query.getResultList(); for(Object obj:resultList)&#123; System.out.println(obj); &#125; tx.commit(); em.close(); &#125; 排序12345678910111213141516171819202122@Test public void testOrders()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); String jpql = &quot;from com.jap.pojo.Customer order by custId desc &quot;; Query query = em.createQuery(jpql); List resultList = query.getResultList(); for(Object obj:resultList)&#123; System.out.println(obj); &#125; tx.commit(); em.close(); &#125; 聚合函数1234567891011121314151617181920@Test public void testCount()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); String jpql = &quot;select count(custId) from com.jap.pojo.Customer&quot;; Query query = em.createQuery(jpql); Object result = query.getSingleResult(); System.out.println(result); tx.commit(); em.close(); &#125; 分页查询1234567891011121314151617181920212223@Test public void testLimit()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); String jpql = &quot;from com.jap.pojo.Customer&quot;; Query query = em.createQuery(jpql); query.setFirstResult(0); query.setMaxResults(2); List result = query.getResultList(); System.out.println(result); tx.commit(); em.close(); &#125; 条件查询1234567891011121314151617181920212223@Test public void testCondition()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); String jpql = &quot;from com.jap.pojo.Customer where custName like ? &quot;; Query query = em.createQuery(jpql); query.setParameter(1,&quot;I%&quot;); List result = query.getResultList(); System.out.println(result); tx.commit(); em.close(); &#125;]]></content>
      <categories>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA的入门案例]]></title>
    <url>%2F2019%2F04%2F02%2FJPA%E7%9A%84%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[由于JPA是sun公司制定的API规范，所以我们不需要导入额外的JPA相关的jar包，只需要导入JPA的提供商的jar包。我们选择Hibernate作为JPA的提供商，所以需要导入Hibernate的相关jar包。 导入jar包123456789101112131415161718192021222324252627282930313233343536373839404142&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hibernate对jpa的支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mysql and MariaDB --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 实体类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 客户实体类 * 配置映射关系 * 1.实体类和表的映射关系 * @Entity 声明这是一个实体类 * @Table 配置实体类和表的映射关系 * name: 配置数据库表的名称 * 2.实体类中属性和表中字段的映射关系 * * */@Entity@Table(name = &quot;cst_customer&quot;)public class Customer &#123; /** * @Id： 声明主键的配置 * @GeneratedValue: 配置主键生成策略 * strategy * GenerationType.IDENTITY： 自增 * * 底层数据库必须支持自动增长 * GenerationType.SEQUENCE : 序列 oracle * * 底层数据库必须支持序列 * GenerationType.TABLE : jpa提供的一种机制 通过一张数据库表的形式帮助我们完成主键自增 * GenerationType.AUTO : 有程序自动的帮助我们选择主键生成策略 * @Column:配置属性和字段的映射关系 * name: 数据库表中字段的名称 * */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;cust_id&quot;) private Long custId; //客户主键 @Column(name = &quot;cust_name&quot;) private String custName; //客户名称 @Column(name = &quot;cust_source&quot;) private String custSource; //客户来源 @Column(name = &quot;cust_industry&quot;) private String custIndustry; //客户所属行业 @Column(name = &quot;cust_level&quot;) private String custLevel; //客户级别 @Column(name = &quot;cust_address&quot;) private String custAddress; //客户地址 @Column(name = &quot;cust_phone&quot;) private String custPhone; //客户的联系方式 @Override public String toString() &#123; return &quot;Customer&#123;&quot; + &quot;custId=&quot; + custId + &quot;, custName=&apos;&quot; + custName + &apos;\&apos;&apos; + &quot;, custSource=&apos;&quot; + custSource + &apos;\&apos;&apos; + &quot;, custIndustry=&apos;&quot; + custIndustry + &apos;\&apos;&apos; + &quot;, custLevel=&apos;&quot; + custLevel + &apos;\&apos;&apos; + &quot;, custAddress=&apos;&quot; + custAddress + &apos;\&apos;&apos; + &quot;, custPhone=&apos;&quot; + custPhone + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125; public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125;&#125; 创建一个文件 persistence.xml 填写配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt; &lt;!--需要配置 persistence-unit 节点 持久化单元格： name:持久化单元格名称 transaction-type:事务管理方式 JTA:分布式事务管理 RESOURCE_LOCAL:本地事务管理 --&gt; &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;!--jpa的实现方式--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!--数据库信息 用户名： javax.persistence.jdbc.user 密码： javax.persistence.jdbc.password 地址： javax.persistence.jdbc.url 数据库驱动： javax.persistence.jdbc.mysql --&gt; &lt;properties&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;rcd520.&quot; /&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql:///jpa&quot; /&gt; &lt;property name=&quot;javax.persistence.jdbc.mysql&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!--可选配置 : 配置jpa实现方的配置信息 显示sql: false | true 自动创建数据库表： create: 程序运行时创建数据库表（如果有表 先删除再创建表） update: 程序运行时创建表（如果有表 不会创建表） none: 不会创建表 --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 创建一个JPA的工具类 1234567891011121314151617181920212223/** * 解决实体管理工厂的浪费资源的耗时问题 * 通过静态代码块 当程序第一次访问此工具类时 创建一个公共的实体管理器工厂对象 * */public class JpaUtils &#123; private static EntityManagerFactory factory; static &#123; //加载配置文件 factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;); &#125; /** * 获取EntityManage对象 */ public static EntityManager getEntityManager()&#123; return factory.createEntityManager(); &#125;&#125; 在JPA 的查询方法中 保存：persist(Object o) 查询：find(Customer.class, 1L)/getReference(Customer.class, 1L) 根据id进行查询 删除：remove(object o) 更新：merge(Object o) 最后测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class JpaTest &#123; /** * 测试JPA的保存 * * JPA的操作步骤 * 加载配置文件创建工厂对象 * 通过实体类管理类工厂获取实体类管理器 * 获取事务对象 开启事务 * 完成增删改查操作 * 提交事务 * 释放资源 */ @Test public void testSave() &#123; //加载配置文件创建工厂对象 //EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;); // 通过实体类管理类工厂获取实体类管理器// EntityManager em = factory.createEntityManager(); EntityManager em = JpaUtils.getEntityManager();// 获取事务对象 开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //开启事务// 完成增删改查操作 Customer customer = new Customer(); customer.setCustName(&quot;小胖&quot;); customer.setCustIndustry(&quot;血池&quot;); //保存 em.persist(customer); //提交事务 tx.commit(); //释放资源 em.close(); &#125; /** * find() 立即加载 */ @Test public void testFind()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer customer = em.find(Customer.class, 1L); System.out.println(customer); tx.commit(); em.close(); &#125; /** * getReference() 延迟加载 或者时 懒加载 */ @Test public void testReference()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer customer = em.getReference(Customer.class, 1L); System.out.println(customer); tx.commit(); em.close(); &#125; /** * 删除 */ @Test public void testRemove()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer customer = em.find(Customer.class, 1L); em.remove(customer); tx.commit(); em.close(); &#125; /** * 更新 * 使用 merge()方法 * */ @Test public void testUpdate()&#123; EntityManager em = JpaUtils.getEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); Customer customer = em.find(Customer.class, 1L); customer.setCustIndustry(&quot;IT&quot;); em.merge(customer); tx.commit(); em.close(); &#125;&#125;]]></content>
      <categories>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM思想]]></title>
    <url>%2F2019%2F04%2F02%2FORM%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[简单了解ORM思想ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射 **主要目的** ：操作实体类就相当于操作数据库表，只需要对象打点调方法就可以实现数据库操作 建立两个映射关系： 实体类和表的与映射关系 实体类中属性与表中字段的映射关系 不再重点关注：sql语句 就能实现操作 实现了ORM思想的框架 ： mybatis,hibarnate,JPA 为什么使用ORM当实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射 JPA概述JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。 JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中 hibernate概述Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 JPA的优势 标准化 容器级特性的支持 简单方便 查询能力 高级特性 JPA与hibernate的关系JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现 JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。]]></content>
      <categories>
        <category>进阶</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法引用]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 方法引用符双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方 法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 System.out 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效： - Lambda表达式写法： s -&gt; System.out.println(s); - 方法引用写法： System.out::println 第一种语义是指：拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。 第二种等效写法的语义是指：直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。 注:Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常 推导与省略如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。下面这段代码将会调用 println 方法的不同重载形式，将函数式接口改为int类型的参数：1234@FunctionalInterface public interface PrintableInteger &#123; void print(int str); &#125; 由于上下文变了之后可以自动推导出唯一对应的匹配重载，所以方法引用没有任何变化： 123456789public class Demo03PrintOverload &#123; private static void printInteger(PrintableInteger data) &#123; data.print(1024); &#125; public static void main(String[] args) &#123; printInteger(System.out::println); &#125; &#125; 这次方法引用将会自动匹配到 println(int) 的重载形式。 通过对象名引用成员方法这是常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法12345public class MethodRefObject &#123; public void printUpperCase(String str) &#123; System.out.println(str.toUpperCase()); &#125; &#125; 函数式接口仍然定义为：1234@FunctionalInterface public interface Printable &#123; void print(String str); &#125; 那么当需要使用这个 printUpperCase 成员方法来替代 Printable 接口的Lambda的时候，已经具有了 MethodRefObject 类的对象实例，则可以通过对象名引用成员方法，代码为：123456789public class Demo04MethodRef &#123; private static void printString(Printable lambda) &#123; lambda.print(&quot;Hello&quot;); &#125; public static void main(String[] args) &#123; MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); &#125; &#125; 通过类名称引用静态方法由于在 java.lang.Math 类中已经存在了静态方法 abs ，所以当我们需要通过Lambda来调用该方法时，有两种写 法。首先是函数式接口：1234@FunctionalInterface public interface Calcable &#123; int calc(int num); &#125; 第一种写法是使用Lambda表达式：12345678public class Demo05Lambda &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(‐10, n ‐&gt; Math.abs(n)); &#125; &#125; 但是使用方法引用的更好写法是：12345678public class Demo06MethodRef &#123; private static void method(int num, Calcable lambda) &#123; System.out.println(lambda.calc(num)); &#125; public static void main(String[] args) &#123; method(‐10, Math::abs); &#125; &#125; 在这个例子中，下面两种写法是等效的： - Lambda表达式： n -&gt; Math.abs(n) - 方法引用： Math::abs 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口1234@FunctionalInterface public interface Greetable &#123; void greet(); &#125; 然后是父类 Human 的内容：12345public class Human &#123; public void sayHello() &#123; System.out.println(&quot;Hello!&quot;); &#125;&#125; 最后是子类 Man 的内容，其中使用了Lambda的写法：123456789101112131415161718192021public class Man extends Human &#123; @Override public void sayHello() &#123; System.out.println(&quot;大家好,我是Man!&quot;); &#125; //定义方法method,参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; //调用method方法,使用Lambda表达式 method(()‐&gt;&#123; //创建Human对象,调用sayHello方法 new Human().sayHello(); &#125;); //简化Lambda method(()‐&gt;new Human().sayHello()); //使用super关键字代替父类对象 method(()‐&gt;super.sayHello()); &#125; &#125; 但是如果使用方法引用来调用父类中的 sayHello 方法会更好，例如另一个子类 Woman 12345678910111213public class Man extends Human &#123; @Override public void sayHello() &#123; System.out.println(&quot;大家好,我是Man!&quot;); &#125; //定义方法method,参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; method(super::sayHello); &#125; &#125; 在这个例子中，下面两种写法是等效的： Lambda表达式： () -&gt; super.sayHello() 方法引用： super::sayHello 通过this引用成员方法this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用。首先是简单的函数式接口：1234@FunctionalInterface public interface Richable &#123; void buy(); &#125; 下面是一个丈夫 Husband 类：12345678public class Husband &#123; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(() ‐&gt; System.out.println(&quot;买套房子&quot;)); &#125; &#125; 开心方法 beHappy 调用了结婚方法 marry ，后者的参数为函数式接口 Richable ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对 Husband 丈夫类进行修改： 1234567891011public class Husband &#123; private void buyHouse() &#123; System.out.println(&quot;买套房子&quot;); &#125; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(() ‐&gt; this.buyHouse()); &#125; &#125; 如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为： 1234567891011public class Husband &#123; private void buyHouse() &#123; System.out.println(&quot;买套房子&quot;); &#125; private void marry(Richable lambda) &#123; lambda.buy(); &#125; public void beHappy() &#123; marry(this::buyHouse); &#125; &#125; 在这个例子中，下面两种写法是等效的： Lambda表达式： () -&gt; this.buyHouse() 方法引用： this::buyHouse 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示。首先是一个简单 的 Person 类123456789101112public class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 然后是用来创建 Person 对象的函数式接口 123public interface PersonBuilder &#123; Person buildPerson(String name); &#125; 要使用这个函数式接口，可以通过Lambda表达式：12345678public class Demo09Lambda &#123; public static void printName(String name, PersonBuilder builder) &#123; System.out.println(builder.buildPerson(name).getName()); &#125; public static void main(String[] args) &#123; printName(&quot;赵丽颖&quot;, name ‐&gt; new Person(name)); &#125; &#125; 但是通过构造器引用，有更好的写法：12345678public class Demo10ConstructorRef &#123; public static void printName(String name, PersonBuilder builder) &#123; System.out.println(builder.buildPerson(name).getName()); &#125; public static void main(String[] args) &#123; printName(&quot;赵丽颖&quot;, Person::new); &#125; &#125; 数组的构造器引用数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：1234@FunctionalInterface public interface ArrayBuilder&#123; int[] buildArray(int length); &#125; 在应用该接口的时候，可以通过Lambda表达式：12345678public class Demo11ArrayInitRef &#123; private static int[] initArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125; public static void main(String[] args) &#123; int[] array = initArray(10, length ‐&gt; new int[length]); &#125; &#125; 但是更好的写法是使用数组的构造器引用：12345678public class Demo12ArrayInitRef &#123; private static int[] initArray(int length, ArrayBuilder builder) &#123; return builder.buildArray(length); &#125; public static void main(String[] args) &#123; int[] array = initArray(10, int[]::new); &#125; &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stream]]></title>
    <url>%2F2019%2F04%2F02%2FStream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带 来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 流式思想概述Stream（流）是一个来自数据源的元素队列元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源 流的来源。 可以是集合，数组 等。 和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（ﬂuent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结 果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以 像链条一样排列，变成一个管道。 获取流java.util.stream.Stream 是Java 8新加入的常用的流接口。（这并不是一个函数式接口。）获取一个流非常简单，有以下几种常用的方式： - 所有的 Collection 集合都可以通过 stream 默认方法获取流； - Stream 接口的静态方法 of 可以获取数组对应的流。 123456789101112131415161718192021222324252627public class Demo1 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张无忌&quot;); list.add(&quot;周芷若&quot;); list.add(&quot;赵敏&quot;); list.add(&quot;张强&quot;); list.add(&quot;张三丰&quot;); /*for(String name : list) &#123; System.out.println(name); &#125;*/ list.stream().filter((s) -&gt; s.startsWith(&quot;张&quot;)).filter((s) -&gt; s.length()==3).forEach((s) -&gt; System.out.println(s)); //获取键值对(键与值的映射关系 entrySet) Map&lt;String ,String &gt; map = new HashMap&lt;&gt;(); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream = entries.stream(); //将数组转换成Stream流 Integer[] arr = &#123;1,23,4,5,6,2&#125;; Stream&lt;Integer&gt; arr1 = Stream.of(arr); &#125;&#125; 常用方法流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。）终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法 逐一处理 forEach虽然方法名字叫 forEach ，但是与for循环中的“for-each”昵称不同。1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理 复习Consumer接口12java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。 Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。 基本使用12345678import java.util.stream.Stream; public class Demo12StreamForEach &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); stream.forEach(name‐&gt; System.out.println(name)); &#125; &#125; 过滤 filter可以通过 filter 方法将一个流转换成另一个子集流。方法签名：1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件 复习Perdicate此前我们已经学习过 java.util.stream.Predicate 函数式接口，其中唯一的抽象方法为： 1boolean test(T t); 该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法 将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。 基本使用Stream流中的 filter 方法基本使用的代码如：1234567import java.util.stream.Stream; public class Demo07StreamFilter &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); &#125; &#125; 在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 映射：map如果需要将流中的元素映射到另一个流中，可以使用 map 方法。方法签名：1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 复习Function接口此前我们已经学习过 java.util.stream.Function 函数式接口，其中唯一的抽象方法为：1R apply(T t); 这可以将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。 基本使用Stream流中的 map 方法基本使用的代码如：12345678import java.util.stream.Stream; public class Demo08StreamMap &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str)); &#125; &#125; 这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。 统计个数：count正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：1long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。 基本使用1234567891011import java.util.stream.Stream; public class Demo09StreamCount &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;)); System.out.println(result.count()); // 2 &#125; &#125; 抓取前几个：limitlimit 方法可以对流进行截取，只取用前n个。方法签名：1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。 基本使用：12345678910import java.util.stream.Stream; public class Demo10StreamLimit &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.limit(2); System.out.println(result.count()); // 2 &#125; &#125; 跳过前几个：skip如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。 基本使用：12345678910import java.util.stream.Stream; public class Demo11StreamSkip &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.skip(2); System.out.println(result.count()); // 1 &#125; &#125; 组合：concat如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的 该方法的基本使用代码如 12345678import java.util.stream.Stream; public class Demo12StreamConcat &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;); Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;); Stream&lt;String&gt; result = Stream.concat(streamA, streamB); &#125; &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式接口]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[函数式接口在Java中是指：有且仅有一个抽象方法的接口。函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导 备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。 只要确保接口中有且仅有一个抽象方法即可：1234 修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; 由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单： @FunctionalInterface注解与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注 解可用于一个接口的定义上： 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 自定义函数式接口对于刚刚定义好的 MyFunctionalInterface 函数式接口，典型使用场景就是作为方法的参数： 123456789101112public class Demo09FunctionalInterface &#123; // 使用自定义的函数式接口作为方法参数 private static void doSomething(MyFunctionalInterface inter) &#123; inter.myMethod(); // 调用自定义的函数式接口方法 &#125; public static void main(String[] args) &#123; // 调用使用函数式接口的方法 doSomething(() ‐&gt; System.out.println(&quot;Lambda执行啦！&quot;)); &#125; &#125; 常用的函数式接口Supplier接口Supplier 接口被称之为生产型接口 指定接口的泛型式什么类型 那么接口中的get方法就会生产什么类型的数据 练习一：123456789101112131415161718192021222324import java.util.function.Supplier;public class Demo1Supplier &#123; //定义一个方法 方法的参数传递Supplier&lt;T&gt;接口 泛型执行String get方法就会返回一个String类型 public static String getString(Supplier&lt;String&gt; sup)&#123; return sup.get(); &#125; public static void main(String[] args) &#123; /*String s = getString(() -&gt; &#123; return &quot;胡歌&quot;; &#125;); System.out.println(s);*/ String s = getString(() -&gt; &quot;黄飞鸿&quot;); System.out.println(s); &#125;&#125; 练习二： 12345678910111213141516171819202122232425262728public class Demo2Supplier &#123; //定义一个方法 用于获取int类型数组中元素的最大值 参数传递Supplier接口 泛型使用Integer public static int getMax(Supplier&lt;Integer&gt; sup)&#123; return sup.get(); &#125; public static void main(String[] args) &#123; //定义一个int类型数组 int[] arr = &#123;100,2,312,43,-52,12,43,-2&#125;; //调用getMax方法 ，方法的参数Supplier是一个函数式接口 所以可以传递Lambda表达式 int maxValue = getMax(() -&gt; &#123; //获取数组的最大值 ，并返回 //定义一个变量 int max = arr[0]; for (int i : arr) &#123; if (i &gt; max) &#123; max = i; &#125; &#125; return max; &#125;); System.out.println(&quot;最大元素是&quot;+maxValue); &#125;&#125; Consumer接口Consumer 接口被称之为消费型接口 指定接口的泛型式什么类型 那么接口中的accept方法就会消费什么类型的数据 练习一：123456789101112131415161718192021222324252627public class Demo1Consumer &#123; //方法的参数传递一个字符串的姓名 //方法参数的传递Consumer接口 泛型使用String //可以使用Consumer接口消费字符串的姓名 public static void method(String name, Consumer&lt;String&gt; con) &#123; con.accept(name); &#125; public static void main(String[] args) &#123; method(&quot;小胖子&quot;,(String name) -&gt; &#123; System.out.println(name); //使用reverse()方法对字符串进行反转 String eman = new StringBuilder(name).reverse().toString(); System.out.println(eman); &#125;); method(&quot;康师傅&quot;,(String name) -&gt; System.out.println(new StringBuilder(name).reverse().toString())); &#125;&#125; 练习二：123456789101112131415161718192021222324/** * Consumer接口的默认方法andThen * 作用：需要两个Consumer接口 可以把两个Consumer接口组合到一起 在对数据进行消费 */public class Demo2Consumer &#123; //定义一个方法 方法的参数传递一个字符串喝两个Consumer接口 Consumer接口的泛型使用字符串 public static void method(String name , Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)&#123; // con1.accept(name); // con2.accept(name); con1.andThen(con2).accept(name); &#125; public static void main(String[] args) &#123; method(&quot;hello&quot;, (name) -&gt; &#123; System.out.println(name.toUpperCase()); &#125;, (name) -&gt; &#123; System.out.println(name.toLowerCase()); &#125;); &#125;&#125; Predicate接口Predicate接口 是对结果进行判断的接口123456789101112131415public class Demo1Predicate &#123; //使用Predicate的text()方法对字符串进行判断 并把结果返回 public static boolean checking(String s, Predicate&lt;String&gt; pre)&#123; return pre.test(s); &#125; public static void main(String[] args) &#123; boolean b = checking(&quot;asdda&quot;, (str) -&gt; str.length() &gt; 5); System.out.println(b); &#125;&#125; 其中 and() or() negate() 方法的简单使用 123456789101112public static boolean checking(String s , Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; return pre1.and(pre2).test(s); //等价于 return pre1.test(s) &amp;&amp; pre2.test(2); &#125;public static boolean checking(String s , Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)&#123; return pre1.or(pre2).test(s); //等价于 return pre1.test(s) || pre2.test(2); &#125; public static boolean checking(String s , Predicate&lt;String&gt; pre)&#123; return pre.negate().test(s); //等价于 return !pre1.test(s); &#125; 综合练习1234567891011121314151617181920212223public class Demo5Test &#123; public static List&lt;String&gt; checking(String[] arr , Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s : arr) &#123; boolean b = pre1.and(pre2).test(s); if(b)&#123; list.add(s); &#125; &#125; return list; &#125; public static void main(String[] args) &#123; String[] arr = &#123;&quot;马云,男&quot;,&quot;马化腾,男&quot;,&quot;董明珠,女&quot;&#125;; List&lt;String&gt; list = checking(arr, (s) -&gt; s.split(&quot;,&quot;)[0].length() &gt; 2, (s) -&gt; s.split(&quot;,&quot;)[1].contains(&quot;女&quot;)); System.out.println(list); &#125;&#125; Function接口Function接口有两个泛型 输入什么类型转换成指定类型 练习一：123456789101112131415161718public class Demo1Function &#123; /** * 方法参数传递 一个Function接口 泛型使用&lt;String ,Integer&gt; * 使用Function接口传递中的方法apply，把支付穿争行 转化为Integer类型整数 * */ public static void change(String str, Function&lt;String ,Integer&gt; fun)&#123; Integer apply = fun.apply(str); System.out.println(apply); &#125; public static void main(String[] args) &#123; change(&quot;13&quot;,(s) -&gt; Integer.parseInt(s)); &#125;&#125; 练习二：123456789101112131415161718192021public class Demo2Function &#123; /** * * 使用Function函数式接口 andThen()方法 * * 参数传一个字符串类型的整数 * 参数在传递两个function 接口 * 一个泛型接口Function&lt;String,Integer&gt; * 一个泛型接口Function&lt;Integer,String&gt; * */ public static void change(String str, Function&lt;String ,Integer&gt; fun1 ,Function&lt;Integer,String &gt; fun2)&#123; String s = fun1.andThen(fun2).apply(str); System.out.println(s); &#125; public static void main(String[] args) &#123; change(&quot;123&quot;,(s) -&gt; Integer.parseInt(s)+10,(i)-&gt; i+&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2019%2F04%2F01%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数式编程思想概述在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想: 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 冗余的Runnable代码传统写法当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 12345678910111213public class Demo01Runnable &#123; public static void main(String[] args) &#123; // 匿名内部类 Runnable task = new Runnable() &#123; @Override public void run() &#123; // 覆盖重写抽象方法 System.out.println(&quot;多线程任务执行！&quot;); &#125; &#125;; new Thread(task).start(); // 启动线程 &#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 编程思想转换做什么，而不是怎么做 我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345public class Demo02LambdaRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程 &#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： (参数类型 参数名称) -&gt; { 代码语句 } 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 练习：使用Lambda标准格式（无参无返回）给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下： 123public interface Cook &#123; void makeFood();&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789public class Demo05InvokeCook &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 &#125; private static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125; 解答:12345public static void main(String[] args) &#123; invokeCook(() -&gt; &#123; System.out.println(&quot;吃饭啦！&quot;); &#125;);&#125; 备注：小括号代表Cook接口makeFood抽象方法的参数为空，大括号代表makeFood的方法体。 Lambda的参数和返回值 需求: 使用数组存储多个Person对象 对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序 下面举例演示java.util.Comparator接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person &#123; private String name; private int age; // 省略构造器、toString方法与Getter Setter &#125; 传统写法如果使用传统的代码对Person[]数组进行排序，写法如下：1234567891011121314151617181920212223242526import java.util.Arrays;import java.util.Comparator;public class Demo06Comparator &#123; public static void main(String[] args) &#123; // 本来年龄乱序的对象数组 Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 这种做法在面向对象的思想中，似乎也是“理所当然”的。其中Comparator接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。 下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法12345678910111213141516171819import java.util.Arrays;public class Demo07ComparatorLambda &#123; public static void main(String[] args) &#123; Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; Arrays.sort(array, (Person a, Person b) -&gt; &#123; return a.getAge() - b.getAge(); &#125;); for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 使用Lambda标准格式（有参有返回）给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： 123public interface Calculator &#123; int calc(int a, int b);&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算：12345678910public class Demo08InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println(&quot;结果是：&quot; + result); &#125;&#125; 解答12345public static void main(String[] args) &#123; invokeCalc(120, 130, (int a, int b) -&gt; &#123; return a + b; &#125;);&#125; 备注：小括号代表Calculator接口calc抽象方法的参数，大括号代表calc的方法体。 Lambda省略格式可推导即可省略Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： 123public static void main(String[] args) &#123; invokeCalc(120, 130, (a, b) -&gt; a + b);&#125; 省略规则 在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池思想概述我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 线程池概念线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码：1234567891011121314public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;我要一个教练&quot;); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName()); System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;); &#125;&#125; 线程池测试类: 1234567891011121314151617181920212223public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等待唤醒机制]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 为什么要处理线程间通信：多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源：多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 什么是等待唤醒机制这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。总结如下：如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。 包子资源类: 12345public class BaoZi &#123; String pier ; String xianer ; boolean flag = false ;//包子资源 是否存在 包子资源状态&#125; 吃货线程类:1234567891011121314151617181920212223242526public class ChiHuo extends Thread&#123; private BaoZi bz; public ChiHuo(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; while(true)&#123; synchronized (bz)&#123; if(bz.flag == false)&#123;//没包子 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;吃货正在吃&quot;+bz.pier+bz.xianer+&quot;包子&quot;); bz.flag = false; bz.notify(); &#125; &#125; &#125;&#125; 包子铺线程类: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BaoZiPu extends Thread &#123; private BaoZi bz; public BaoZiPu(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; int count = 0; //造包子 while(true)&#123; //同步 synchronized (bz)&#123; if(bz.flag == true)&#123;//包子资源 存在 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 没有包子 造包子 System.out.println(&quot;包子铺开始做包子&quot;); if(count%2 == 0)&#123; // 冰皮 五仁 bz.pier = &quot;冰皮&quot;; bz.xianer = &quot;五仁&quot;; &#125;else&#123; // 薄皮 牛肉大葱 bz.pier = &quot;薄皮&quot;; bz.xianer = &quot;牛肉大葱&quot;; &#125; count++; bz.flag=true; System.out.println(&quot;包子造好了：&quot;+bz.pier+bz.xianer); System.out.println(&quot;吃货来吃吧&quot;); //唤醒等待线程 （吃货） bz.notify(); &#125; &#125; &#125;&#125; 测试类: 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; //等待唤醒案例 BaoZi bz = new BaoZi(); ChiHuo ch = new ChiHuo(&quot;吃货&quot;,bz); BaoZiPu bzp = new BaoZiPu(&quot;包子铺&quot;,bz); ch.start(); bzp.start(); &#125;&#125; 执行效果: 12345678910111213包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子包子铺开始做包子包子造好了：薄皮牛肉大葱吃货来吃吧吃货正在吃薄皮牛肉大葱包子包子铺开始做包子包子造好了：冰皮五仁吃货来吃吧吃货正在吃冰皮五仁包子]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们通过一个案例，演示线程的安全问题：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个 (本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟 123456789101112131415161718192021222324252627 public class Ticket implements Runnable &#123; private int ticket = 100; /* *执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while (true) &#123; if (ticket &gt; 0) &#123; //有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name + &quot;正在卖:&quot; + ticket‐‐); &#125; &#125; &#125;&#125; 测试类：123456789101112131415public class Demo &#123; public static void main(String[] args) &#123; //创建线程任务对象 Ticket ticket = new Ticket(); //创建三个窗口对象 Thread t1 = new Thread(ticket, &quot;窗口1&quot;); Thread t2 = new Thread(ticket, &quot;窗口2&quot;); Thread t3 = new Thread(ticket, &quot;窗口3&quot;); //同时卖票 t1.start(); t2.start(); t3.start(); &#125; &#125; 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (synchronized)来解决。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。那么怎么去使用呢？有三种方式完成同步操作： 同步代码块。 同步方法。 锁机制。 同步代码块同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁:对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 1. 锁对象 可以是任意类型。 2. 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着使用同步代码块解决代码123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (this) &#123; if(ticket&gt;0)&#123; //有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket‐‐); &#125; &#125; &#125; &#125;&#125; 当使用了同步代码块后，线程的安全问题，解决了 同步方法同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外 等着 格式：123public synchronized void run() &#123;&#125; 同步锁是谁?对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 Lock锁java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作, 同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。Lock锁也称同步锁，加锁与释放锁方法化了，如下： - public void lock() :加同步锁。 - public void unlock() :释放同步锁。 public class Ticket implements Runnable{ private int ticket = 100; Lock l = new ReentrantLock(); @Override public void run() { while (true){ //判断票是否存在 l.lock(); try { if(tickt&gt;0){ System.out.println(Thread.currentThread().getName()+&quot;正在买第&quot;+tickt+&quot;张票&quot;); tickt--; } } catch (Exception e) { e.printStackTrace(); }finally { l.unlock(); } } } }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 线程与进程进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度: 分时调度所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 创建线程类一Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 自定义线程类 1234567891011121314151617public class MyThread extends Thread &#123;//定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+&quot;：正在执行！&quot;+i); &#125; &#125;&#125; 测试类123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(&quot;新的线程！&quot;); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;main线程！&quot;+i); &#125; &#125;&#125; 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了 Thread类java.lang.Thread 类， API中该类中定义了有关线程的一些方法，具体如下： public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。public Thread(Runnable target) :分配一个带有指定目标新的线程对象。public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。常用方法：public String getName() :获取当前线程名称。public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。public void run() :此线程要执行的任务在此处定义代码。public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread() :返回对当前正在执行的线程对象的引用。翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一已经完成，接下来讲解方式二实现的方式。 创建线程方式二采用 java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。 3. 调用线程对象的start()方法来启动线程。12345678910111213141516171819202122232425 public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财 &quot; + i); &#125; &#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享总结：实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法 123456789101112131415161718192021222324 public class NoNameInnerClassThread &#123; public static void main(String[] args) &#123; // new Runnable()&#123; // public void run()&#123; // for (int i = 0; i &lt; 20; i++) &#123; // System.out.println(&quot;张宇:&quot;+i); // &#125; // &#125; // &#125;; //‐‐‐这个整体 相当于new MyRunnable() Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125; &#125;; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;费玉清:&quot;+i); &#125; &#125; &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义异常]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException：1234567891011121314151617// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 12345678910111213141516171819202122232425262728public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(&quot;nill&quot;); System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常的处理]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： throw new 异常类名(参数); 例如： throw new NullPointerException(“要访问的arr数组不存在”); throw new ArrayIndexOutOfBoundsException(“该索引在数组中不存在，已超出范围”); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。12345678910111213141516171819202122232425262728public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(&quot;over&quot;); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了~~~&quot;); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作：12345678910111213public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; //简化写法 Objects.requireNonNull(parse); //或者 Objects.requireNonNull(parse,&quot;进行合法性判断&quot;); &#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 声明异常的代码演示：12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(&quot;a.txt&quot;); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 12345678910111213141516public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(&quot;a.txt&quot;); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; if (!path.equals(&quot;b.txt&quot;)) &#123; throw new IOException(); &#125; &#125;&#125; 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下：123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(&quot;b.txt&quot;); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 123456789101112131415161718192021222324public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(&quot;a.txt&quot;); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下：12345678910try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(&quot;num=&quot; + num); System.out.println(&quot;over&quot;); &#125;&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pegehelper-分页助手]]></title>
    <url>%2F2019%2F03%2F29%2Fpegehelper-%E5%88%86%E9%A1%B5%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[分页助手 POM配置12345678&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt;&lt;/dependency&gt; 这次直接是在项目的入口类application.java中直接设置PageHelper插件即可 123456789101112//配置mybatis的分页插件pageHelper @Bean public PageHelper pageHelper()&#123; PageHelper pageHelper = new PageHelper(); Properties properties = new Properties(); properties.setProperty(&quot;offsetAsPageNum&quot;,&quot;true&quot;); properties.setProperty(&quot;rowBoundsWithCount&quot;,&quot;true&quot;); properties.setProperty(&quot;reasonable&quot;,&quot;true&quot;); properties.setProperty(&quot;dialect&quot;,&quot;mysql&quot;); //配置mysql数据库的方言 pageHelper.setProperties(properties); return pageHelper; &#125; 在springBoot项目中 POM配置 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 使用用法12345678910111213141516171819202122// 先创建一个实体工具类 来保存分页数据@Datapublic class PageResult&lt;T&gt; &#123; private Long total; //总条数 private Integer totalPage;//总页数 private List&lt;T&gt; items; //当前分页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Integer totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125;&#125; 使用一个案例方法讲述分页用法 123456789101112131415161718192021222324252627282930313233343536373839@Autowired private BrandMapper brandMapper; page 当前页 rows 每页大小 sortBy 排序字段 desc 是否降序 key 搜索条件 public PageResult&lt;Brand&gt; QueryBrandByPage(Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; //分页 通过分页插件 PageHelper.startPage(page,rows); //过滤 Example example = new Example(Brand.class); if(StringUtils.isNotBlank(key))&#123; //过滤条件 example.createCriteria().orLike(&quot;name&quot;,&quot;%&quot;+key+&quot;%&quot;).orEqualTo(&quot;letter&quot;,key.toUpperCase()); &#125; //排序 if(StringUtils.isNoneBlank(sortBy))&#123; String orederByClauce = sortBy+(desc ? &quot; DESC&quot;:&quot; ASC&quot; ); example.setOrderByClause(orederByClauce); &#125; //查询 List&lt;Brand&gt; brands = brandMapper.selectByExample(example); if(CollectionUtils.isEmpty(brands))&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; //解析分页结果 PageInfo&lt;Brand&gt; info = new PageInfo&lt;&gt;(brands); return new PageResult&lt;&gt;(info.getTotal(),brands); &#125; 这就使分页助手 pegehelper 的简单使用]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步查询工具axios]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7axios%2F</url>
    <content type="text"><![CDATA[异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库 Vue官方推荐的ajax请求框架叫做：axios axios小入门先导入axios的js文件 axios的Get请求语法12345678910111213141516axios.get(&quot;/item/category/list?pid=0&quot;) // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get(&quot;/item/category/list&quot;, &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法123456axios.post(&quot;/user&quot;,&#123; name:&quot;Jack&quot;, age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 可以设置axios的基础请求路径 和请求时间12axios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cors解决跨域]]></title>
    <url>%2F2019%2F03%2F29%2Fcors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端：目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端：CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 实现 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了 在网关服务中编写一个配置类12345678910111213141516171819202122232425262728293031323334353637import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(&quot;http://manage.leyou.com&quot;); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&quot;OPTIONS&quot;); config.addAllowedMethod(&quot;HEAD&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;PUT&quot;); config.addAllowedMethod(&quot;POST&quot;); config.addAllowedMethod(&quot;DELETE&quot;); config.addAllowedMethod(&quot;PATCH&quot;); // 4）允许的头信息 config.addAllowedHeader(&quot;*&quot;); // 5 有效时长 config.setMaxAge(3600L); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&quot;/**&quot;, config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 然后重新启动测试]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之全局异常处理2]]></title>
    <url>%2F2019%2F03%2F29%2FSpringBoot%E4%B9%8B%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%862%2F</url>
    <content type="text"><![CDATA[全局处理异常步骤第一步12345678910111213141516//创建一个枚举类@Getter@NoArgsConstructorpublic enum ExceptionMuns &#123; MY_ERROR(404,&quot;找不到&quot;), ; private Integer status; private String mseeage; ExceptionMuns(Integer status, String mseeage) &#123; this.status = status; this.mseeage = mseeage; &#125;&#125; 第二步123456789101112131415@Datapublic class ExceptionResult &#123; private Integer code; private String message; private Long timestamp; public ExceptionResult(ExceptionMuns e) &#123; this.code = e.getStatus(); this.message = e.getMseeage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 第三步123456789@Getter@AllArgsConstructor@NoArgsConstructorpublic class MyException extends RuntimeException &#123; private ExceptionMuns exceptionMuns;&#125; 第四步123456789101112131415161718/***全局异常拦截**/@ControllerAdvice //拦截所有加了controler注解的类public class ExceptionAdtive &#123; /** * 遵循Result风格 */ @ExceptionHandler(MyException.class) public ResponseEntity&lt;ExceptionResult&gt; ExceptionAdtive(MyException e)&#123; return ResponseEntity.status(e.getExceptionMuns().getStatus()) .body(new ExceptionResult(e.getExceptionMuns())); &#125; &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Zuul网关]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BZuul%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[使用Spring Cloud实现微服务的架构基本成型，大致是这样的: 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 编写启动类通过@EnableZuulProxy注解开启Zuul的功能：12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 映射规则：12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8081 启动测试：访问的路径中需要加上配置规则的映射路径 面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： 默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 路由前缀配置示例：123456zuul: prefix: /api # 添加路由前缀 routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 service-id: user-service # 指定服务名称 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 ZuulFilterZuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 过滤器执行生命周期 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行 定义过滤器类1234567891011121314151617181920212223242526272829303132@Componentpublic class LoginFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER -1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; //获取请求的参数 RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); //判断是否存在 String parameter = request.getParameter(&quot;access-token&quot;); if(StringUtils.isBlank(parameter))&#123; //不存在，未登录，则拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); &#125; return null; &#125;&#125; 测试 没有token参数时，访问失败： 添加token参数后：访问成功 负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 123456789101112131415zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms ribbon的超时时长，真实值是（read+connect）*2,必须小于hystrix熔断超时时长 最终配置 1234567891011121314151617181920212223242526272829303132server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekazuul: prefix: /api # 添加路由前缀 routes: item-service: /item/** upload-service: path: /upload/** serviceId: upload-service strip-prefix: false add-host-header: true # API网关在进行请求路由转发前为请求设置Host头信息 sensitive-headers: # 默认情况下，敏感的头信息无法经过API网关进行传递，我们可以通过如下配置使之可以传递hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 50000 # 熔断超时时长：10000msribbon: ConnectTimeout: 5000 # 连接超时时间(ms) ReadTimeout: 5000 # 通信超时时间(ms) MaxAutoRetriesNextServer: 0 # 同一服务不同实例的重试次数 MaxAutoRetries: 0 # 同一实例的重试次数]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Feign远程调用]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BFeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们使用过Ribbon的负载均衡功能，大大简化了远程调用时的代码：12String baseUrl = &quot;http://user-service/user/&quot;;User user = this.restTemplate.getForObject(baseUrl + id, User.class) Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 快速入门 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Feign的客户端123456@FeignClient(&quot;user-service&quot;)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125; 开启Feign功能我们在启动类上，添加注解，开启Feign功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 启动测试, 访问接口： 负载均衡Feign中本身已经集成了Ribbon依赖和自动配置：因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置：1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 Hystix支持 Feign默认也有对Hystix的集成： 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为 fallback的处理类12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName(&quot;用户查询出现异常！&quot;); return user; &#125;&#125; 然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = &quot;user-service&quot;, fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryUserById(@PathVariable(&quot;id&quot;) Long id);&#125; 重启测试： 我们关闭user-service服务，然后在页面访问：]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Hystix熔断]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BHystix%E7%86%94%E6%96%AD%2F</url>
    <content type="text"><![CDATA[Hystix，即熔断器。主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败 熔断器的工作机制：正常工作的情况下，客户端请求调用服务API接口：当有服务出现异常时，直接进行失败回滚，服务降级处理：当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 引入依赖首先入Hystix依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断在启动类上添加@EnableCircuitBreaker 或者只添加@SpringCloudApplication改造消费者 我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：1234567891011121314151617181920212223242526@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = &quot;queryUserByIdFallback&quot;) public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = &quot;http://user-service/user/&quot; + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info(&quot;访问用时：&#123;&#125;&quot;, end - begin); return user; &#125; public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName(&quot;用户信息查询出现异常！&quot;); return user; &#125;&#125; @HystrixCommand(fallbackMethod=”queryUserByIdFallback”)`：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 为了方便查看熔断的触发时机，我们记录请求访问时间。 也可以将@DefaultProperties(defaultFallback = “queryByIdFallback”) 配置在类上声明该类方法的默认就会执行fallback函数，返回错误提示 在原来的业务逻辑中调用这个DAO： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125; 改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 启动测试 然后运行并查看日志： 根据id进行访问 优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms 123456789默认的熔断出发要求比较高，休眠时间窗比较短 为了方便测试可以通过配置修改熔断策略circuitBreaker.requestVolumeThreshold=10circuitBreaker.sleepWindowInMilliseconds=10000circuitBreaker.errorThresholdPercentage=50解读：requestVolumeThreshold：出发熔断的最小请求次数 默认为20sleepWindowInMilliseconds：休眠时长 默认是5000毫秒errorThresholdPercentage：触发熔断的失败请求最小占比 默认是50%]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之负载均衡Robbin]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8B%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Robbin%2F</url>
    <content type="text"><![CDATA[在Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 接下来，我们就来使用Ribbon实现负载均衡。 启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。 开启负载均衡因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：在RestTemplate的配置方法上添加@LoadBalanced注解：12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = &quot;http://user-service/user/&quot;; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果：完美 负载均衡策略默认是使用轮询 SpringBoot也帮我们提供了修改负载均衡规则的配置入口：在配置文件中添加123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 再次测试，发现结果变成了随机 重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 关闭一个user-service实例:因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。只需要简单配置即可实现Ribbon的重试：12345678910111213spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Eureka注册中心]]></title>
    <url>%2F2019%2F03%2F07%2FSpringBoot%E4%B9%8BEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[原理图Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址提供者：启动后向Eureka注册自己信息（地址，提供什么服务）消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 pom.xml文件12345678910111213141516171819202122&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 根据需要导入依赖即可 编写启动类：123456789@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置：以yml文件的方式配置1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:10086/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 将user-service注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。先添加SpringCloud依赖：然后是Eureka客户端：12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置123456789101112131415161718192021server: port: 8081spring: datasource: url: jdbc:mysql://localhost:3306/mydb01 username: root password: 123 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.leyou.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意：这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看，看见有 user-service 大写的名称就说明服务注册成功了消费者从Eureka获取服务 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！、先添加SpringCloud依赖：然后是Eureka客户端：和之前的依赖是一样的在启动类开启Eureka客户端修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：123456789101112131415161718192021222324@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = &quot;http://localhost:8081/user/&quot;; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;user-service&quot;); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = &quot;http://&quot;+instance.getHost() + &quot;:&quot; + instance.getPort()+&quot;/user/&quot;; users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); return users; &#125;&#125; 最后根据你的路径访问，查看数据 Eureka详解基础架构Eureka架构中的三个核心角色： 服务注册中心Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087我们修改原来的EurekaServer配置：123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 另外一台配置恰好相反：123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：1234eureka: client: service-url: # EurekaServer地址,多个地址以&apos;,&apos;隔开 defaultZone: http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka 服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。服务续约在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 服务消费者 获取服务列表当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 失效剔除和自我保护失效剔除有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告：这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的RestTemplate]]></title>
    <url>%2F2019%2F03%2F07%2FSpring%E7%9A%84RestTemplate%2F</url>
    <content type="text"><![CDATA[系统之间调用Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：1.HttpClient2.OkHttp3.JDK原生的URLConnection（默认的）首先在项目中注册一个RestTemplate对象，可以在启动类位置注册：1234567891011121314@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject(&quot;http://localhost/hello&quot;, User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程调用方式RPC与http]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8FRPC%E4%B8%8Ehttp%2F</url>
    <content type="text"><![CDATA[远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。现在热门的Rest风格，就可以通过http协议来实现。 RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现. 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。]]></content>
      <categories>
        <category>http&amp;RPC</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统架构演变]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键存在的问题 1.代码耦合，开发维护困难 2.无法针对不同模块进行针对性优化 3.无法水平扩展 4.单点容错率低，并发能力差 垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：优点： 1.系统拆分实现了流量分担，解决了并发问题 2.可以针对不同模块进行优化 3.方便水平扩展，负载均衡，容错率提高缺点： 1.系统间相互独立，会有很多重复开发工作，影响开发效率 分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别：微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 - - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图]]></content>
      <categories>
        <category>系统架构</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件application.properties]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6application-properties%2F</url>
    <content type="text"><![CDATA[下面列出其所有的配置 application.properties 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363# ----------------------------------------# CORE PROPERTIES# ----------------------------------------# SPRING 相关配置 (ConfigFileApplicationListener)spring.config.name= # config file name (default to &apos;application&apos;)spring.config.location= # location of config file# profile相关配置spring.profiles= # comma list of active profiles# 系统配置相关参数 (SpringApplication)spring.main.sources=spring.main.web-environment= # detect by defaultspring.main.show-banner=truespring.main....= # see class for all properties# 日志配置相关参数logging.path=/var/logslogging.file=myapp.loglogging.config=# IDENTITY (ContextIdApplicationContextInitializer)spring.application.name=spring.application.index=# tomcat相关配置参数 (ServerProperties)server.port=8080server.address= # bind to a specific NICserver.session-timeout= # session timeout in secondsserver.context-path= # the context path, defaults to &apos;/&apos;server.servlet-path= # the servlet path, defaults to &apos;/&apos;server.tomcat.access-log-pattern= # log pattern of the access logserver.tomcat.access-log-enabled=false # is access logging enabledserver.tomcat.protocol-header=x-forwarded-proto # ssl forward headersserver.tomcat.remote-ip-header=x-forwarded-forserver.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)server.tomcat.background-processor-delay=30; # in secondsserver.tomcat.max-threads = 0 # number of threads in protocol handlerserver.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding# springmvc相关配置参数 (HttpMapperProperties)http.mappers.json-pretty-print=false # pretty print JSONhttp.mappers.json-sort-keys=false # sort keysspring.mvc.locale= # set fixed locale, e.g. en_UKspring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyyspring.mvc.message-codes-resolver-format= # PREFIX_ERROR_CODE / POSTFIX_ERROR_CODEspring.view.prefix= # MVC view prefixspring.view.suffix= # ... and suffixspring.resources.cache-period= # cache timeouts in headers sent to browserspring.resources.add-mappings=true # if default mappings should be added# thymeleaf相关配置参数 (ThymeleafAutoConfiguration)spring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/html # ;charset=&lt;encoding&gt; is addedspring.thymeleaf.cache=true # set to false for hot refresh# freemark相关配置参数 (FreeMarkerAutoConfiguration)spring.freemarker.allowRequestOverride=falsespring.freemarker.allowSessionOverride=falsespring.freemarker.cache=truespring.freemarker.checkTemplateLocation=truespring.freemarker.contentType=text/htmlspring.freemarker.exposeRequestAttributes=falsespring.freemarker.exposeSessionAttributes=falsespring.freemarker.exposeSpringMacroHelpers=falsespring.freemarker.prefix=spring.freemarker.requestContextAttribute=spring.freemarker.settings.*=spring.freemarker.suffix=.ftlspring.freemarker.templateEncoding=UTF-8spring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.viewNames= # whitelist of view names that can be resolved# groovy模板相关配置参数 (GroovyTemplateAutoConfiguration)spring.groovy.template.allowRequestOverride=falsespring.groovy.template.allowSessionOverride=falsespring.groovy.template.cache=truespring.groovy.template.configuration.*= # See Groovy&apos;s TemplateConfigurationspring.groovy.template.contentType=text/htmlspring.groovy.template.prefix=classpath:/templates/spring.groovy.template.suffix=.tplspring.groovy.template.templateEncoding=UTF-8spring.groovy.template.viewNames= # whitelist of view names that can be resolved# velocity模板相关配置参数 (VelocityAutoConfiguration)spring.velocity.allowRequestOverride=falsespring.velocity.allowSessionOverride=falsespring.velocity.cache=truespring.velocity.checkTemplateLocation=truespring.velocity.contentType=text/htmlspring.velocity.dateToolAttribute=spring.velocity.exposeRequestAttributes=falsespring.velocity.exposeSessionAttributes=falsespring.velocity.exposeSpringMacroHelpers=falsespring.velocity.numberToolAttribute=spring.velocity.prefix=spring.velocity.properties.*=spring.velocity.requestContextAttribute=spring.velocity.resourceLoaderPath=classpath:/templates/spring.velocity.suffix=.vmspring.velocity.templateEncoding=UTF-8spring.velocity.viewNames= # whitelist of view names that can be resolved# INTERNATIONALIZATION (MessageSourceAutoConfiguration)spring.messages.basename=messagesspring.messages.cacheSeconds=-1spring.messages.encoding=UTF-8# 安全相关配置参数 (SecurityProperties)security.user.name=user # login usernamesecurity.user.password= # login passwordsecurity.user.role=USER # role assigned to the usersecurity.require-ssl=false # advanced settings ...security.enable-csrf=falsesecurity.basic.enabled=truesecurity.basic.realm=Springsecurity.basic.path= # /**security.headers.xss=falsesecurity.headers.cache=falsesecurity.headers.frame=falsesecurity.headers.contentType=falsesecurity.headers.hsts=all # none / domain / allsecurity.sessions=stateless # always / never / if_required / statelesssecurity.ignored=false# 数据源相关配置参数(DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.name= # name of the data sourcespring.datasource.initialize=true # populate using data.sqlspring.datasource.schema= # a schema (DDL) script resource referencespring.datasource.data= # a data (DML) script resource referencespring.datasource.platform= # the platform to use in the schema resource (schema-$&#123;platform&#125;.sql)spring.datasource.continueOnError=false # continue even if can&apos;t be initializedspring.datasource.separator=; # statement separator in SQL initialization scriptsspring.datasource.driverClassName= # JDBC Settings...spring.datasource.url=spring.datasource.username=spring.datasource.password=spring.datasource.max-active=100 # Advanced configuration...spring.datasource.max-idle=8spring.datasource.min-idle=8spring.datasource.initial-size=10spring.datasource.validation-query=spring.datasource.test-on-borrow=falsespring.datasource.test-on-return=falsespring.datasource.test-while-idle=spring.datasource.time-between-eviction-runs-millis=spring.datasource.min-evictable-idle-time-millis=spring.datasource.max-wait-millis=# mongdb相关配置参数 (MongoProperties)spring.data.mongodb.host= # the db hostspring.data.mongodb.port=27017 # the connection port (defaults to 27107)spring.data.mongodb.uri=mongodb://localhost/test # connection URLspring.data.mongo.repositories.enabled=true # if spring data repository support is enabled# springDataJPA相关配置参数(JpaBaseConfiguration, HibernateJpaAutoConfiguration)spring.jpa.properties.*= # properties to set on the JPA connectionspring.jpa.openInView=truespring.jpa.show-sql=truespring.jpa.database-platform=spring.jpa.database=spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendorsspring.jpa.hibernate.naming-strategy= # naming classnamespring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbsspring.data.jpa.repositories.enabled=true # if spring data repository support is enabled# solr相关配置参数(SolrProperties&#125;)spring.data.solr.host=http://127.0.0.1:8983/solrspring.data.solr.zkHost=spring.data.solr.repositories.enabled=true # if spring data repository support is enabled# elasticsearch相关配置参数(ElasticsearchProperties&#125;)spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch)spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node)spring.data.elasticsearch.local=true # if local mode should be used with client nodesspring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled# flyway相关配置参数(FlywayProperties)flyway.locations=classpath:db/migrations # locations of migrations scriptsflyway.schemas= # schemas to updateflyway.initVersion= 1 # version to start migrationflyway.prefix=Vflyway.suffix=.sqlflyway.enabled=trueflyway.url= # JDBC url if you want Flyway to create its own DataSourceflyway.user= # JDBC username if you want Flyway to create its own DataSourceflyway.password= # JDBC password if you want Flyway to create its own DataSource# liquibase相关配置参数(LiquibaseProperties)liquibase.change-log=classpath:/db/changelog/db.changelog-master.yamlliquibase.contexts= # runtime contexts to useliquibase.default-schema= # default database schema to useliquibase.drop-first=falseliquibase.enabled=true# JMXspring.jmx.enabled=true # Expose MBeans from Spring# rabbitmq相关配置参数(RabbitProperties)spring.rabbitmq.host= # connection hostspring.rabbitmq.port= # connection portspring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111)spring.rabbitmq.username= # login userspring.rabbitmq.password= # login passwordspring.rabbitmq.virtualhost=spring.rabbitmq.dynamic=# redis相关配置参数(RedisProperties)spring.redis.host=localhost # server hostspring.redis.password= # server passwordspring.redis.port=6379 # connection portspring.redis.pool.max-idle=8 # pool settings ...spring.redis.pool.min-idle=0spring.redis.pool.max-active=8spring.redis.pool.max-wait=-1# activemq相关配置参数(ActiveMQProperties)spring.activemq.broker-url=tcp://localhost:61616 # connection URLspring.activemq.user=spring.activemq.password=spring.activemq.in-memory=true # broker kind to create if no broker-url is specifiedspring.activemq.pooled=false# hornetq相关配置参数(HornetQProperties)spring.hornetq.mode= # connection mode (native, embedded)spring.hornetq.host=localhost # hornetQ host (native mode)spring.hornetq.port=5445 # hornetQ port (native mode)spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar)spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer)spring.hornetq.embedded.persistent=false # message persistencespring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled)spring.hornetq.embedded.queues= # comma separate queues to create on startupspring.hornetq.embedded.topics= # comma separate topics to create on startupspring.hornetq.embedded.cluster-password= # customer password (randomly generated by default)# JMS (JmsProperties)spring.jms.pub-sub-domain= # false for queue (default), true for topic# springbatch相关配置参数(BatchDatabaseInitializer)spring.batch.job.names=job1,job2spring.batch.job.enabled=truespring.batch.initializer.enabled=truespring.batch.schema= # batch schema to load# aop相关配置参数spring.aop.auto=spring.aop.proxy-target-class=# FILE ENCODING (FileEncodingApplicationListener)spring.mandatory-file-encoding=false# SPRING SOCIAL (SocialWebAutoConfiguration)spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own# SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)spring.social.facebook.app-id= # your application&apos;s Facebook App IDspring.social.facebook.app-secret= # your application&apos;s Facebook App Secret# SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)spring.social.linkedin.app-id= # your application&apos;s LinkedIn App IDspring.social.linkedin.app-secret= # your application&apos;s LinkedIn App Secret# SPRING SOCIAL TWITTER (TwitterAutoConfiguration)spring.social.twitter.app-id= # your application&apos;s Twitter App IDspring.social.twitter.app-secret= # your application&apos;s Twitter App Secret# SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)spring.mobile.sitepreference.enabled=true # enabled by default# SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by defaultspring.mobile.devicedelegatingviewresolver.normalPrefix=spring.mobile.devicedelegatingviewresolver.normalSuffix=spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/spring.mobile.devicedelegatingviewresolver.mobileSuffix=spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/spring.mobile.devicedelegatingviewresolver.tabletSuffix=# ----------------------------------------# ACTUATOR PROPERTIES# ----------------------------------------# MANAGEMENT HTTP SERVER (ManagementServerProperties)management.port= # defaults to &apos;server.port&apos;management.address= # bind to a specific NICmanagement.contextPath= # default to &apos;/&apos;# ENDPOINTS (AbstractEndpoint subclasses)endpoints.autoconfig.id=autoconfigendpoints.autoconfig.sensitive=trueendpoints.autoconfig.enabled=trueendpoints.beans.id=beansendpoints.beans.sensitive=trueendpoints.beans.enabled=trueendpoints.configprops.id=configpropsendpoints.configprops.sensitive=trueendpoints.configprops.enabled=trueendpoints.configprops.keys-to-sanitize=password,secretendpoints.dump.id=dumpendpoints.dump.sensitive=trueendpoints.dump.enabled=trueendpoints.env.id=envendpoints.env.sensitive=trueendpoints.env.enabled=trueendpoints.health.id=healthendpoints.health.sensitive=falseendpoints.health.enabled=trueendpoints.info.id=infoendpoints.info.sensitive=falseendpoints.info.enabled=trueendpoints.metrics.id=metricsendpoints.metrics.sensitive=trueendpoints.metrics.enabled=trueendpoints.shutdown.id=shutdownendpoints.shutdown.sensitive=trueendpoints.shutdown.enabled=falseendpoints.trace.id=traceendpoints.trace.sensitive=trueendpoints.trace.enabled=true# MVC ONLY ENDPOINTSendpoints.jolokia.path=jolokiaendpoints.jolokia.sensitive=trueendpoints.jolokia.enabled=true # when using Jolokiaendpoints.error.path=/error# JMX ENDPOINT (EndpointMBeanExportProperties)endpoints.jmx.enabled=trueendpoints.jmx.domain= # the JMX domain, defaults to &apos;org.springboot&apos;endpoints.jmx.unique-names=falseendpoints.jmx.enabled=trueendpoints.jmx.staticNames=# JOLOKIA (JolokiaProperties)jolokia.config.*= # See Jolokia manual# REMOTE SHELLshell.auth=simple # jaas, key, simple, springshell.command-refresh-interval=-1shell.command-path-pattern= # classpath*:/commands/**, classpath*:/crash/commands/**shell.config-path-patterns= # classpath*:/crash/*shell.disabled-plugins=false # don&apos;t expose pluginsshell.ssh.enabled= # ssh settings ...shell.ssh.keyPath=shell.ssh.port=shell.telnet.enabled= # telnet settings ...shell.telnet.port=shell.auth.jaas.domain= # authentication settings ...shell.auth.key.path=shell.auth.simple.user.name=shell.auth.simple.user.password=shell.auth.spring.roles=# GIT INFOspring.git.properties= # resource ref to generated git info properties file]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot应用启动器]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[spring Boot应用启动器基本的一共有44种，具体如下:1.spring-boot-starter这是Spring Boot的核心启动器，包含了自动配置、日志和YAML。 2.spring-boot-starter-actuator帮助监控和管理应用。 3.spring-boot-starter-amqp通过spring-rabbit来支持AMQP协议（Advanced Message Queuing Protocol）。 4.spring-boot-starter-aop支持面向方面的编程即AOP，包括spring-aop和AspectJ。 5.spring-boot-starter-artemis通过Apache Artemis支持JMS的API（Java Message Service API）。 6.spring-boot-starter-batch支持Spring Batch，包括HSQLDB数据库。 7.spring-boot-starter-cache支持Spring的Cache抽象。 8.spring-boot-starter-cloud-connectors支持Spring Cloud Connectors，简化了在像Cloud Foundry或Heroku这样的云平台上连接服务。 9.spring-boot-starter-data-elasticsearch支持ElasticSearch搜索和分析引擎，包括spring-data-elasticsearch。 10.spring-boot-starter-data-gemfire支持GemFire分布式数据存储，包括spring-data-gemfire。 11.spring-boot-starter-data-jpa支持JPA（Java Persistence API），包括spring-data-jpa、spring-orm、hibernate。 12.spring-boot-starter-data-MongoDB支持MongoDB数据，包括spring-data-mongodb。 13.spring-boot-starter-data-rest通过spring-data-rest-webmvc，支持通过REST暴露Spring Data数据仓库。 14.spring-boot-starter-data-solr支持Apache Solr搜索平台，包括spring-data-solr。 15.spring-boot-starter-freemarker支持FreeMarker模板引擎。 16.spring-boot-starter-groovy-templates支持Groovy模板引擎。 17.spring-boot-starter-hateoas通过spring-hateoas支持基于HATEOAS的RESTful Web服务。 18.spring-boot-starter-hornetq通过HornetQ支持JMS。 19.spring-boot-starter-integration支持通用的spring-integration模块。 20.spring-boot-starter-jdbc支持JDBC数据库。 21.spring-boot-starter-jersey支持Jersey RESTful Web服务框架。 22.spring-boot-starter-jta-atomikos通过Atomikos支持JTA分布式事务处理。 23.spring-boot-starter-jta-bitronix通过Bitronix支持JTA分布式事务处理。 24.spring-boot-starter-mail支持javax.mail模块。 25.spring-boot-starter-mobile支持spring-mobile。 26.spring-boot-starter-mustache支持Mustache模板引擎。 27.spring-boot-starter-Redis支持Redis键值存储数据库，包括spring-redis。 28.spring-boot-starter-security支持spring-security。 29.spring-boot-starter-social-facebook支持spring-social-facebook 30.spring-boot-starter-social-linkedin支持pring-social-linkedin 31.spring-boot-starter-social-twitter支持pring-social-twitter 32.spring-boot-starter-test支持常规的测试依赖，包括JUnit、Hamcrest、Mockito以及spring-test模块。 33.spring-boot-starter-thymeleaf支持Thymeleaf模板引擎，包括与Spring的集成。 34.spring-boot-starter-velocity支持Velocity模板引擎。 35.spring-boot-starter-webS支持全栈式Web开发，包括Tomcat和spring-webmvc。 36.spring-boot-starter-websocket支持WebSocket开发。 37.spring-boot-starter-ws支持Spring Web Services。Spring Boot应用启动器面向生产环境的还有2种，具体如下： 1.spring-boot-starter-actuator增加了面向产品上线相关的功能，比如测量和监控。 2.spring-boot-starter-remote-shell增加了远程ssh shell的支持。最后，Spring Boot应用启动器还有一些替换技术的启动器，具体如下： 1.spring-boot-starter-jetty引入了Jetty HTTP引擎（用于替换Tomcat）。 2.spring-boot-starter-log4j支持Log4J日志框架。 3.spring-boot-starter-logging引入了Spring Boot默认的日志框架Logback。 4.spring-boot-starter-tomcat引入了Spring Boot默认的HTTP引擎Tomcat。 5.spring-boot-starter-undertow引入了Undertow HTTP引擎（用于替换Tomcat）。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot使用AOP统一处理Web请求日志]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E4%BD%BF%E7%94%A8AOP%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[首先添加aop依赖123456&lt;!-- AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 写一个切面类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.gyf.aop;import java.util.Enumeration;import javax.servlet.http.HttpServletRequest;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@Aspect@Componentpublic class WebLogAspect &#123; private Logger logger = Logger.getLogger(getClass()); @Pointcut(&quot;execution(public * com.gyf.controller..*.*(..))&quot;) public void webLog() &#123; &#125; @Before(&quot;webLog()&quot;) public void doBefore(JoinPoint joinPoint) throws Throwable &#123; // 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 记录下请求内容 logger.info(&quot;---------------request----------------&quot;); logger.info(&quot;URL : &quot; + request.getRequestURL().toString()); logger.info(&quot;HTTP_METHOD : &quot; + request.getMethod()); logger.info(&quot;IP : &quot; + request.getRemoteAddr()); Enumeration&lt;String&gt; enu = request.getParameterNames(); while (enu.hasMoreElements()) &#123; String name = (String) enu.nextElement(); logger.info(&quot;name:&quot; + name + &quot;value&quot; + request.getParameter(name)); &#125; &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;) public void doAfterReturning(Object ret) throws Throwable &#123; logger.info(&quot;---------------response----------------&quot;); // 处理完请求，返回内容 logger.info(&quot;RESPONSE : &quot; + ret); &#125;&#125; @Aspect:作用是把当前类标识为一个切面供容器读取Aspect的意思是面向切面编程，一个类前面加上@Aspect说明这个类使用了这个技术，很有可能是在进行声明式事务处理 1.这里的可以把这里public void webLog() {}方法理解成具体pointcut（切入点）的声明，实际对应的切入点是“execution(public * com.cc.springboot.controller…(..))”； 2.@AfterReturning，是在具体业务方法返回后的操作（比如下面IndexController类中的getUserName()方法），所以returning=”ret”对应的是业务方法 的返回值，不是切入点声明的返回值，也就是returning=”ret”的“ret”就是具体的方法(public * com.cc.springboot.controller…(..))的返回值，对应public void afterReturning(ret returnValue) 的方法参数，名称一定要对应，在方法返回后，可以进行一些操作，比如输出返回值或者根据返回值进行一些操作。 然后开启Spring 随便使用一个业务方法 就可以看到控制台打印的日志了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Log4j]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88Log4j%2F</url>
    <content type="text"><![CDATA[Spring Boot 配合log4j实现日志输出 导入Log4j属性文件log4j.properties注意，复制时要把每一行后面的空格去除 这里配置的 日志文件地址为 C:/Users/10301/Desktop/test/logs/info/info.log1234567891011121314log4j.rootLogger=INFO,Console,File log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.outlog4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c - %L]%m%n log4j.appender.File = org.apache.log4j.RollingFileAppender log4j.appender.File.File = C:/Users/10301/Desktop/test/logs/info/info.log log4j.appender.File.MaxFileSize = 10MB log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c - %L]%m%n 配置pom.xml 去除springboot的logging，添加log4j，因为自带的logging不启效果springboot下的Log4j的版本最新1.3.8，如果你的springboot的parent版本过高，那在在添加log4j自己版本 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;groupId&gt;com.micai&lt;/groupId&gt; &lt;artifactId&gt;micai-springboot-log4j-8&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;micai-springboot-log4j-8&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- Spring Boot web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Spring Boot log4j依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ##具体打印日志的java类，如下： 123456789101112131415161718192021package com.micai.springboot.web; import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestController //提供实现了REST API，可以服务JSON,XML或者其他。这里是以String的形式渲染出结果。public class HelloWorldController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(&quot;/&quot;) //提供路由信息，”/“路径的HTTP Request都会被映射到sayHello方法进行处理。 public String sayHello()&#123; logger.info(&quot;hello world&quot;); return &quot;Hello,World!&quot;; &#125; &#125; 启动Spring 就可以在上面的路径的日志文件中看到运行日志]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MyBatis配置多个数据源]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88MyBatis%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[配置文件中新增两个数据源12345678910spring.datasource.test1.driverClassName=com.mysql.jdbc.Driverspring.datasource.test1.url=jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.test1.username=rootspring.datasource.test1.password=123456spring.datasource.test2.driverClassName=com.mysql.jdbc.Driverspring.datasource.test2.url=jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.test2.username=rootspring.datasource.test2.password=123456 在数据库中创建两个数据库12345678910111213141516use test1;CREATE table user( id int PRIMARY KEY AUTO_INCREMENT, username VARCHAR(50), password VARCHAR(50), email VARCHAR(50), birthday TIMESTAMP);use test2;CREATE table customer( id int PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), tel VARCHAR(50)); 再src下先创建两个包 com.gyf.test1.mapper ， com.gyf.test2.mapper 编写两个数据源配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//----------text1package com.gyf.datasource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test1.mapper&quot;,sqlSessionFactoryRef=&quot;test1SqlSessionFactory&quot;)public class DataSource01 &#123; /** * @return 返回test1数据库的数据源 */ @Bean(name=&quot;test1DataSource&quot;) @Primary//主数据源 @ConfigurationProperties(prefix=&quot;spring.datasource.test1&quot;) public DataSource dateSource()&#123; return DataSourceBuilder.create().build(); &#125; /** * @return 返回test1数据库的会话工厂 */ @Bean(name = &quot;test1SqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource ds) throws Exception&#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); return bean.getObject(); &#125; /** * @return 返回test1数据库的事务 */ @Bean(name = &quot;test1TransactionManager&quot;) @Primary public DataSourceTransactionManager transactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; /** * @return 返回test1数据库的会话模版 */ @Bean(name = &quot;test1SqlSessionTemplate&quot;) public SqlSessionTemplate sqlSessionTemplate( @Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125;//------------text2package com.gyf.datasource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test2.mapper&quot;,sqlSessionFactoryRef=&quot;test2SqlSessionFactory&quot;)public class DataSource02 &#123; /** * @return 返回test2数据库的数据源 */ @Bean(name=&quot;test2DataSource&quot;) @ConfigurationProperties(prefix=&quot;spring.datasource.test2&quot;) public DataSource dateSource()&#123; return DataSourceBuilder.create().build(); &#125; /** * @return 返回test2数据库的会话工厂 */ @Bean(name = &quot;test2SqlSessionFactory&quot;) public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;test2DataSource&quot;) DataSource ds) throws Exception&#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); return bean.getObject(); &#125; /** * @return 返回test2数据库的事务 */ @Bean(name = &quot;test2TransactionManager&quot;) public DataSourceTransactionManager transactionManager(@Qualifier(&quot;test2DataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; /** * @return 返回test2数据库的会话模版 */ @Bean(name = &quot;test2SqlSessionTemplate&quot;) public SqlSessionTemplate sqlSessionTemplate( @Qualifier(&quot;test2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 然后编写Mapper里的类和映射SQL的xml文件如果使用的是com.gyf.test1.mapper下的类就是使用的第一个数据源的数据如果使用的是com.gyf.test2.mapper下的类就是使用的第二个数据源的数据 如果你在一个service的方法里同时使用了两个数据源 开启了事务注解 @Transactoinal 并出现了的异常很显然，有多个事务，容器不知道我们要的是哪个事务、如何解决这个错误 下面会给大家讲解 springboot中的多事务管理使用springboot+jta+atomikos 分布式事物管理解决方案 添加jta事务依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt;&lt;/dependency&gt; 修改数据库连接配置数据 123456789101112131415161718192021222324252627# Mysql 1mysql.datasource.test1.url = jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8mysql.datasource.test1.username = rootmysql.datasource.test1.password = 123456mysql.datasource.test1.minPoolSize = 3mysql.datasource.test1.maxPoolSize = 25mysql.datasource.test1.maxLifetime = 20000mysql.datasource.test1.borrowConnectionTimeout = 30mysql.datasource.test1.loginTimeout = 30mysql.datasource.test1.maintenanceInterval = 60mysql.datasource.test1.maxIdleTime = 60mysql.datasource.test1.testQuery = select 1# Mysql 2mysql.datasource.test2.url =jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8mysql.datasource.test2.username =rootmysql.datasource.test2.password =123456mysql.datasource.test2.minPoolSize = 3mysql.datasource.test2.maxPoolSize = 25mysql.datasource.test2.maxLifetime = 20000mysql.datasource.test2.borrowConnectionTimeout = 30mysql.datasource.test2.loginTimeout = 30mysql.datasource.test2.maintenanceInterval = 60mysql.datasource.test2.maxIdleTime = 60mysql.datasource.test2.testQuery = select 1 添加2个配置模型 模型放在com.gyf.dbconfig包 12345678910111213141516171819202122232425262728293031323334353637@ConfigurationProperties(&quot;mysql.datasource.test1&quot;)public class DBConfig1 &#123; private String url; private String username; private String password; private int minPoolSize; private int maxPoolSize; private int maxLifetime; private int borrowConnectionTimeout; private int loginTimeout; private int maintenanceInterval; private int maxIdleTime; private String testQuery; ...... &#125; @ConfigurationProperties(&quot;mysql.datasource.test2&quot;)public class DBConfig2 &#123; private String url; private String username; private String password; private int minPoolSize; private int maxPoolSize; private int maxLifetime; private int borrowConnectionTimeout; private int loginTimeout; private int maintenanceInterval; private int maxIdleTime; private String testQuery; ...... &#125; 重定两个数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.gyf.datasource;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.gyf.dbconfig.DBConfig1;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test1.mapper&quot;,sqlSessionFactoryRef=&quot;test1SqlSessionFactory&quot;)public class DataSource01 &#123; // 配置数据源 @Primary @Bean(name = &quot;test1DataSource&quot;) public DataSource testDataSource(DBConfig1 testConfig) throws SQLException &#123; MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(testConfig.getUrl()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); mysqlXaDataSource.setPassword(testConfig.getPassword()); mysqlXaDataSource.setUser(testConfig.getUsername()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName(&quot;test1DataSource&quot;); xaDataSource.setMinPoolSize(testConfig.getMinPoolSize()); xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize()); xaDataSource.setMaxLifetime(testConfig.getMaxLifetime()); xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout()); xaDataSource.setLoginTimeout(testConfig.getLoginTimeout()); xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval()); xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime()); xaDataSource.setTestQuery(testConfig.getTestQuery()); return xaDataSource; &#125; @Bean(name = &quot;test1SqlSessionFactory&quot;) public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; @Bean(name = &quot;test1SqlSessionTemplate&quot;) public SqlSessionTemplate testSqlSessionTemplate( @Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125;-------------------------------------------------------package com.gyf.datasource;import java.sql.SQLException;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.atomikos.jdbc.AtomikosDataSourceBean;import com.gyf.dbconfig.DBConfig2;import com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;@Configuration//注解到springboot容器中@MapperScan(basePackages=&quot;com.gyf.test2.mapper&quot;,sqlSessionFactoryRef=&quot;test2SqlSessionFactory&quot;)public class DataSource02 &#123; // 配置数据源 @Bean(name = &quot;test2DataSource&quot;) public DataSource testDataSource(DBConfig2 testConfig) throws SQLException &#123; MysqlXADataSource mysqlXaDataSource = new MysqlXADataSource(); mysqlXaDataSource.setUrl(testConfig.getUrl()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); mysqlXaDataSource.setPassword(testConfig.getPassword()); mysqlXaDataSource.setUser(testConfig.getUsername()); mysqlXaDataSource.setPinGlobalTxToPhysicalConnection(true); AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean(); xaDataSource.setXaDataSource(mysqlXaDataSource); xaDataSource.setUniqueResourceName(&quot;test2DataSource&quot;); xaDataSource.setMinPoolSize(testConfig.getMinPoolSize()); xaDataSource.setMaxPoolSize(testConfig.getMaxPoolSize()); xaDataSource.setMaxLifetime(testConfig.getMaxLifetime()); xaDataSource.setBorrowConnectionTimeout(testConfig.getBorrowConnectionTimeout()); xaDataSource.setLoginTimeout(testConfig.getLoginTimeout()); xaDataSource.setMaintenanceInterval(testConfig.getMaintenanceInterval()); xaDataSource.setMaxIdleTime(testConfig.getMaxIdleTime()); xaDataSource.setTestQuery(testConfig.getTestQuery()); return xaDataSource; &#125; @Bean(name = &quot;test2SqlSessionFactory&quot;) public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test2DataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; @Bean(name = &quot;test2SqlSessionTemplate&quot;) public SqlSessionTemplate testSqlSessionTemplate( @Qualifier(&quot;test2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 在APP类中添加注解12345678910@SpringBootApplication@EnableConfigurationProperties(value = &#123;DBConfig1.class,DBConfig2.class&#125;)public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class,args); &#125;&#125; 这样就解决了多个事务管理问题]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MyBatis]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[什么是 MyBatis ？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录 如何让将MyBatis与SpringBoot进行整合pom导入 1234567891011121314151617181920212223242526272829303132&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.2.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybaties --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.properties文件中属性配置 123456#数据库配置spring.datasource.url=jdbc:mysql://localhost:3306/db?characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver Mapper中以xml形式编写SQL语句 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.gyf.mapper.UserMapper&quot; &gt; &lt;insert id=&quot;save&quot;&gt; insert into t_user (username,password) VALUES(#&#123;0&#125;,#&#123;1&#125;) &lt;/insert&gt; &lt;select id=&quot;findByUsername&quot; resultType=&quot;com.gyf.model.User&quot; parameterType=&quot;string&quot;&gt; select * from t_user where username = #&#123;username,jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 注意这里需要在pom中添加下面代码 1234567891011&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Controller这里为了简写直接在Controller层中引入了Mapper在实际中Mapper是在service层中引入的 1234567891011121314151617181920212223package com.gyf.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.gyf.mapper.UserMapper;import com.gyf.model.User;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserMapper userMapper; @ResponseBody @RequestMapping(&quot;/add/&#123;name&#125;&quot;) public int add(String name)&#123; return userMapper.insert(name,&quot;e10adc3949ba59abbe56e057f20f883e&quot;); &#125;&#125; 运行App类 123456789101112131415package com.gyf.app;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 在浏览器地址栏中 输入localhost:8080/user/add/参数 然后再去数据库查看数据是否添加成功]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Freemarker的使用]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E6%95%B4%E5%90%88Freemarker%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板引擎 Freemarker它是基于模板文件生成其他文本的通用工具FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。当你使用上述模板引擎中的时候，它们默认的模板配置路径为：src/main/resources/templates 特点： 轻量级模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中 能生成各种文本，如html，xml，java，等 入门简单，它是用java编写的，很多语法和java相似 二.Springboot-freemarker工程配置详解 1.pom.xml文件详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot-freemarker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-freemarker :: Spring Boot 集成 FreeMarker 案例&lt;/name&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt; &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Freemarker 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 我们在pom.xml中增加Spring Boot FreeMarker依赖 2.配置FreeMarker 在application.properties中加入FreeMarker相关配置:123456789101112## Freemarker 配置## 文件配置路径spring.freemarker.template-loader-path=classpath:/web/spring.freemarker.cache=falsespring.freemarker.charset=UTF-8spring.freemarker.check-template-location=truespring.freemarker.content-type=text/htmlspring.freemarker.expose-request-attributes=truespring.freemarker.expose-session-attributes=truespring.freemarker.request-context-attribute=requestspring.freemarker.suffix=.ftl ##3.展示层Controller详解 12345678910111213141516171819202122232425/** * @author WJ * @date 2018/04/26 */ @Controller public class CityController &#123; @Autowired private CityService cityService; @RequestMapping(value = &quot;/api/city/&#123;id&#125;&quot;, method = RequestMethod.GET) public String findOne(Model model, @PathVariable(&quot;id&quot;) Long id)&#123; model.addAttribute(&quot;city&quot; , cityService.findOne(id)); return &quot;city&quot;; &#125; @RequestMapping(value = &quot;/api/city&quot;, method = RequestMethod.GET) public String findAll(Model model)&#123; List&lt;City&gt; cityList = cityService.findAll(); model.addAttribute(&quot;cityList&quot;, cityList); return &quot;cityList&quot;; &#125; &#125; 注意 这里不是走HTTP+JSON模式,使用了@Controller而不是先前的@RestController方法返回值是String类型，和.application.properties配置的Freemarker文件配置路径下的各个*.ftl文件名一致，这样才会准确的把数据渲染到ftl文件里面进行展示用Model类，向Model加入数据，并指定在该数据在Freemarker取值指定的名称。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot全局捕获异常]]></title>
    <url>%2F2019%2F03%2F05%2FSpringBoot%E5%85%A8%E5%B1%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[@ExceptionHeandler 表示拦截异常@ControllerAdivcecontroller 的一个辅助类，最常用的就是全局异常处理的切面类可以指定扫描范围约定了几种可行的返回值，如果是直接返回model类的话，需要使用@ResponseBody进行JSON转换 案例 在一个自己定义的包中创建一个全局异常类12345678910111213@ControllerAdvice//切面public class GlobalExceptionHandler &#123; @ExceptionHandler(RuntimeException.class)//捕获运行时异常 @ResponseBody public Map&lt;String,Object&gt; exceptionHander()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;errorCode&quot;, &quot;101&quot;); map.put(&quot;errorMsg&quot;, &quot;系統错误!&quot;); return map; &#125;&#125; 在某个的映射的方法中添加上 int i =10/0 的算术异常 然后再启动Spring 最后在浏览器地址栏中输入该方法的路径 如果页面显示 12&#123;&quot;errorCode&quot;:&quot;101&quot;,&quot;errorMsg&quot;:&quot;系統错误&quot;&#125; 那么就说明SpringBoot的全局捕获异常设置成功]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云深]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%BA%91%E6%B7%B1%2F</url>
    <content type="text"><![CDATA[云深第一篇文章这是三级列表哦 列表1 列表2 a 字体列表哦 b 字体列表哈 列表3 云深导航 字体是斜线的字体是加粗的 &lt;html&gt;&lt;/html&gt; 这个123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 在博客中添加图片 ![云深不知处](图片路径) &lt;/body&gt;&lt;/html&gt; 这里的内容是引用的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
